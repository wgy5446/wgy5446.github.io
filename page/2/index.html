<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wgy5446.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="All story about js">
<meta property="og:type" content="website">
<meta property="og:title" content="John">
<meta property="og:url" content="https://wgy5446.github.io/page/2/index.html">
<meta property="og:site_name" content="John">
<meta property="og:description" content="All story about js">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="wgy5446">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content=" js">
<meta property="article:tag" content=" react">
<meta property="article:tag" content=" anqular">
<meta property="article:tag" content=" hhkb">
<meta property="article:tag" content=" realforce">
<meta property="article:tag" content=" leopold">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wgy5446.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>John</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">John</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">John</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/03/%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/" class="post-title-link" itemprop="url">프로퍼티 어트리뷰트</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-03 22:38:14 / Modified: 23:33:48" itemprop="dateCreated datePublished" datetime="2020-03-03T22:38:14+09:00">2020-03-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-내부-슬롯과-내부-메소드"><a href="#1-내부-슬롯과-내부-메소드" class="headerlink" title="1. 내부 슬롯과 내부 메소드"></a>1. 내부 슬롯과 내부 메소드</h2><p>내부 슬롯과 내부 메소드는 자바스크립트 엔진의 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메소드이다. ECMAScript 사양에 등장하는 이중 대괄호 ([[…]])로 감싼 이름들이 내부 슬롯과 내부 메소드이다. 내부 슬롯과 내부 메소드는 자바스크립트 엔진의 내부 로직이므로 원칙적으로 자바스크립트는 내부 슬롯과 내부 메소드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다. 일부 내부 슬롯과 내부 메소드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.</p>
<hr>
<h2 id="2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h2><p>자바스크립트 엔진은 프로퍼티를 생성할 때, 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다. 프로퍼티의 상태란 프로퍼티의 값, 값의 갱신 기능 여부, 열거 가능 여부, 재정의 가능 여부를 말한다. 프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값인 내부 슬롯이다. 따라서 프로퍼티 어트리뷰트에 직접 접근할 수 없지만, Object.getOwnPropertyDescriptor 메소드를 사용하여 간접적으로 확인할 수는 있다. 메소드를 호출할 때, 첫번째 매개변수에는 객체의 참조를 전달하고 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다. 이때 메소드는 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.</p>
<hr>
<h2 id="3-데이터-프로퍼티와-접근자-프로퍼티"><a href="#3-데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="3. 데이터 프로퍼티와 접근자 프로퍼티"></a>3. 데이터 프로퍼티와 접근자 프로퍼티</h2><ul>
<li>데이터 프로퍼티키와 값으로 구성된 일반적인 프로퍼티다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.</li>
<li>접근자 프로퍼티 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티다.</li>
</ul>
<hr>
<h3 id="3-1-데이터-프로퍼티"><a href="#3-1-데이터-프로퍼티" class="headerlink" title="3-1. 데이터 프로퍼티"></a>3-1. 데이터 프로퍼티</h3><ul>
<li>프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체의 프로퍼티 종류와 설명<ul>
<li>[[Value]], value : 프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값이고, 프로퍼티 키로 프로퍼티 값을 저장하면 [[value]]에 값을 저장한다. 이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.</li>
<li>[[Writable]], writable : 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖으며, [[Writable]]의 값이 false인 경우, 해당 프로퍼티의[[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.</li>
<li>[[Enumerable]], enumerable : 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖으며, [[Enumerable]]의 값이 false인 경우, 해당 프로퍼티는 for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다.</li>
<li>[[configurable]], configurable :  프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖으며, [[Configurable]]의 값이 false인 경우, 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-접근자-프로퍼티"><a href="#3-2-접근자-프로퍼티" class="headerlink" title="3-2. 접근자 프로퍼티"></a>3-2. 접근자 프로퍼티</h3><ul>
<li>프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체의 프로퍼티 종류와 설명<ul>
<li>[[Get]], get : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수이다. 즉, 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.</li>
<li>[[Set]], set : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수이다. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</li>
<li>[[Enumerable]], enumerable : 데이터 프로퍼티의 [[Enumerable]]와 같다.</li>
<li>[[Configurable]], configurable : 데이터 프로퍼티의 [[Configurable]]와 같다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-프로퍼티의-정의"><a href="#4-프로퍼티의-정의" class="headerlink" title="4. 프로퍼티의 정의"></a>4. 프로퍼티의 정의</h2><p>프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다.</p>
<h2 id="5-객체-변경-방지"><a href="#5-객체-변경-방지" class="headerlink" title="5. 객체 변경 방지"></a>5. 객체 변경 방지</h2><p>객체는 변경 가능한 값이므로 재할당없이 직접 변경이 가능하다. 프로퍼티를 추가하거나 삭제할 수 있고, 프로퍼티의 값을 갱신할 수 있으며 Object.defineProperty 또는 Object.defineProperties 메소드를 사용하여 프로퍼티 어트리뷰트를 재정의할 수도 있다.</p>
<ul>
<li>객체 확장 금지 Object.preventExtensions로 프로퍼티 추가 X, 프로퍼티 삭제 O, 프로퍼티 값 읽기 O, 프로퍼티 값 쓰기 O, 프로퍼티 어트리뷰트 재정의 O.</li>
<li>객체 밀봉 Object.seal로 프로퍼티 추가 X, 프로퍼티 삭제 X, 프로퍼티 값 읽기 O, 프로퍼티 값 쓰기 O, 프로퍼티 어트리뷰트 재정의 O.</li>
<li>객체 동결 Object.freeze로 프로퍼티 추가 X, 프로퍼티 삭제 X, 프로퍼티 값 읽기 O, 프로퍼티 값 쓰기 X, 프로퍼티 어트리뷰트 재정의 X.</li>
</ul>
<hr>
<h3 id="5-1-객체-확장-금지"><a href="#5-1-객체-확장-금지" class="headerlink" title="5-1. 객체 확장 금지"></a>5-1. 객체 확장 금지</h3><p>Object.preventExtensions 메소드는 객체의 확장을 금지한다. 즉, 확장이 금지된 객체는 프로퍼티 추가가 금지된다.</p>
<hr>
<h3 id="5-2-객체-밀봉"><a href="#5-2-객체-밀봉" class="headerlink" title="5-2. 객체 밀봉"></a>5-2. 객체 밀봉</h3><p>Object.seal 메소드는 객체를 밀봉한다. 즉, 밀봉된 객체는 읽기와 쓰기만 가능하게 된다.</p>
<hr>
<h3 id="5-3-객체-동결"><a href="#5-3-객체-동결" class="headerlink" title="5-3. 객체 동결"></a>5-3. 객체 동결</h3><p>Object.freeze 메소드는 객체를 동결한다. 즉, 동결된 객체는 읽기만 가능하게 된다.</p>
<hr>
<h3 id="5-4-불변-객체"><a href="#5-4-불변-객체" class="headerlink" title="5-4. 불변 객체"></a>5-4. 불변 객체</h3><p>객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용의 불변 객체를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메소드를 호출해야 한다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/02/%EB%B8%94%EB%A1%9D%EB%A0%88%EB%B2%A8%EC%8A%A4%EC%BD%94%ED%94%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/%EB%B8%94%EB%A1%9D%EB%A0%88%EB%B2%A8%EC%8A%A4%EC%BD%94%ED%94%84/" class="post-title-link" itemprop="url">let, const와 블록 레벨 스코프</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-28 22:18:26 / Modified: 22:53:54" itemprop="dateCreated datePublished" datetime="2020-02-28T22:18:26+09:00">2020-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-var-키워드로-선언한-변수의-문제점"><a href="#1-var-키워드로-선언한-변수의-문제점" class="headerlink" title="1. var 키워드로 선언한 변수의 문제점"></a>1. var 키워드로 선언한 변수의 문제점</h2><h3 id="1-1-변수-중복-선언-허용"><a href="#1-1-변수-중복-선언-허용" class="headerlink" title="1-1. 변수 중복 선언 허용"></a>1-1. 변수 중복 선언 허용</h3><p>var 키워드로 선언한 변수는 중복 선언이 가능하다. 변수의 중복 선언은 문법적으로 허용되지만 사용하지 않는 것이 좋다.</p>
<hr>
<h3 id="1-2-함수-레벨-스코프"><a href="#1-2-함수-레벨-스코프" class="headerlink" title="1-2. 함수 레벨 스코프"></a>1-2. 함수 레벨 스코프</h3><p>var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var키워드로 선언한 변수는 코드 블록 내에서 선언하여도 모두 전역 변수가 된다.</p>
<hr>
<h3 id="1-3-변수-호이스팅"><a href="#1-3-변수-호이스팅" class="headerlink" title="1-3. 변수 호이스팅"></a>1-3. 변수 호이스팅</h3><p>var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉, 변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다.</p>
<hr>
<h2 id="2-let-키워드"><a href="#2-let-키워드" class="headerlink" title="2. let 키워드"></a>2. let 키워드</h2><h3 id="2-1-변수-중복-선언-금지"><a href="#2-1-변수-중복-선언-금지" class="headerlink" title="2-1. 변수 중복 선언 금지"></a>2-1. 변수 중복 선언 금지</h3><p>let 키워드로 동일한 이름을 갖는 변수를 선언하면 문법 에러가 발생한다.</p>
<hr>
<h3 id="2-2-블록-레벨-스코프"><a href="#2-2-블록-레벨-스코프" class="headerlink" title="2-2. 블록 레벨 스코프"></a>2-2. 블록 레벨 스코프</h3><p>let 키워드로 선언한 변수는 모든 코드 블록(함수,if문,for문,while문,try/catch 문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.</p>
<hr>
<h3 id="2-3-변수-호이스팅"><a href="#2-3-변수-호이스팅" class="headerlink" title="2-3. 변수 호이스팅"></a>2-3. 변수 호이스팅</h3><p>let 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행된다. 즉, 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다. 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 일시적 사각지대라고 부른다. let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.</p>
<hr>
<h3 id="2-4-전역-객체와-let"><a href="#2-4-전역-객체와-let" class="headerlink" title="2-4. 전역 객체와 let"></a>2-4. 전역 객체와 let</h3><p>전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다.<br>전역 객체는 브라우저에서는 window, 서버 사이드 환경에서는 global 객체를 가리킨다.</p>
<hr>
<h2 id="3-const-키워드"><a href="#3-const-키워드" class="headerlink" title="3. const 키워드"></a>3. const 키워드</h2><h3 id="3-1-선언과-초기화"><a href="#3-1-선언과-초기화" class="headerlink" title="3-1. 선언과 초기화"></a>3-1. 선언과 초기화</h3><p>const 키워드로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야 한다. 그렇지 않으면 아래와 같이 문법 에러가 발생한다.<br>블록 레벨 스코프를 가지며 변수 호이스팅이 발생하지 않는 것처럼 동작한다.</p>
<hr>
<h3 id="3-2-재할당-금지"><a href="#3-2-재할당-금지" class="headerlink" title="3-2. 재할당 금지"></a>3-2. 재할당 금지</h3><p>const 키워드로 선언한 변수는 재할당이 금지된다.</p>
<h3 id="3-3-상수"><a href="#3-3-상수" class="headerlink" title="3-3. 상수"></a>3-3. 상수</h3><p>const 키워드로 선언한 변수에 원시값을 할당한 경우, 변수값을 변경할 수 없다. 원시값은 변경 불가능한 값이므로 재할당없이 값을 변경할 수 있는 방법이 없기 때문이다. 이러한 특징을 이용해 const 키워드를 상수를 표현하는 데 사용하기도 한다. 재할당이 금지된다. 상수는 상태 유지와 가독성,유지보수의 편의를 위해 적극적으로 사용해야 한다.</p>
<hr>
<h3 id="3-3-const-키워드와-객체"><a href="#3-3-const-키워드와-객체" class="headerlink" title="3-3. const 키워드와 객체"></a>3-3. const 키워드와 객체</h3><p>const 키워드로 선언된 변수에 객체를 할당한 경우, 값을 변경할 수 있다. const 키워드는 재할당을 금지할 뿐 불변을 의미하지는 않는다.</p>
<hr>
<h3 id="4-var-vs-let-vs-const"><a href="#4-var-vs-let-vs-const" class="headerlink" title="4. var vs. let vs. const"></a>4. var vs. let vs. const</h3><p>변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다. 원시 값의 경우, 가급적 상수를 사용하는 편이 좋다. 그리고 객체를 재할당하는 경우는 생각보다 흔하지 않다. const 키워드를 사용하면 의도치 않은 재할당을 방지해 주기 때문에 보다 안전하다.</p>
<ul>
<li>ES6를 사용한다면 var 키워드는 사용하지 않는다.</li>
<li>재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.</li>
<li>변경이 발생하지 않고 읽기 전용으로 사용하는 원시 값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 안전하다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/02/%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98%EB%AC%B8%EC%A0%9C%EC%A0%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98%EB%AC%B8%EC%A0%9C%EC%A0%90/" class="post-title-link" itemprop="url">전역 변수의 문제점</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-27 22:54:43 / Modified: 23:19:00" itemprop="dateCreated datePublished" datetime="2020-02-27T22:54:43+09:00">2020-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-변수의-생명-주기"><a href="#1-변수의-생명-주기" class="headerlink" title="1. 변수의 생명 주기"></a>1. 변수의 생명 주기</h2><h3 id="1-1-지역-변수의-생명-주기"><a href="#1-1-지역-변수의-생명-주기" class="headerlink" title="1-1. 지역 변수의 생명 주기"></a>1-1. 지역 변수의 생명 주기</h3><p>변수는 생물과 유사하게 생성되고 소멸되는 생명 주기가 있다. 변수는 자신이 선언된 위치에서 생성되고 소멸한다. 전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같다. 하지만 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸된다. 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.</p>
<hr>
<h3 id="1-2-전역-변수의-생명-주기"><a href="#1-2-전역-변수의-생명-주기" class="headerlink" title="1-2. 전역 변수의 생명 주기"></a>1-2. 전역 변수의 생명 주기</h3><p>전역 코드는 함수 호출과 같이 전역 코드를 실행하는 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다. 전역 코드에는 return 문을 사용할 수 없으므로 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료한다. 전역 변수의 생명주기는 전역 객체의 생명 주기와 일치한다.</p>
<hr>
<h2 id="2-전역-변수의-문제점"><a href="#2-전역-변수의-문제점" class="headerlink" title="2. 전역 변수의 문제점"></a>2. 전역 변수의 문제점</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">전역 변수를 선언한 의도는 전역, 즉 코드 어디에서든지 전역 변수를 사용하겠다는 것이다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것으로 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">전역 변수는 생명 주기가 길다. 따라서 메모리 리소스도 오랜 기간 소비한다.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">전역 변수의 검색 속도가 가장 느리다.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">자바스크립트에서 가장 큰 문제점 중의 하나는 파일이 분리되어 있다하여도 하나의 전역 스코프를 공유한다는 것이다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-전역-변수-사용-억제-방법"><a href="#3-전역-변수-사용-억제-방법" class="headerlink" title="3. 전역 변수 사용 억제 방법"></a>3. 전역 변수 사용 억제 방법</h2><p>전역 변수를 반드시 사용하여야 할 이유를 찾지 못한다면 지역 변수를 사용하여야 한다.변수의 스코프는 좁을수록 좋다.</p>
<hr>
<h3 id="3-1-즉시-실행-함수"><a href="#3-1-즉시-실행-함수" class="headerlink" title="3-1. 즉시 실행 함수"></a>3-1. 즉시 실행 함수</h3><p>모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 이러한 특성을 이용해 전역 변수의 사용을 제한하는 방법이다.</p>
<hr>
<h3 id="3-2-네임-스페이스-객체"><a href="#3-2-네임-스페이스-객체" class="headerlink" title="3-2. 네임 스페이스 객체"></a>3-2. 네임 스페이스 객체</h3><p>전역에 네임 스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.</p>
<hr>
<h3 id="3-3-모듈-패턴"><a href="#3-3-모듈-패턴" class="headerlink" title="3-3. 모듈 패턴"></a>3-3. 모듈 패턴</h3><p>모듈 패턴은 클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 모듈 패턴은 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다. 모듈 패턴의 특징은 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다는 것이다.</p>
<hr>
<h3 id="3-4-ES6-모듈"><a href="#3-4-ES6-모듈" class="headerlink" title="3-4. ES6 모듈"></a>3-4. ES6 모듈</h3><p>전역 변수의 남발을 억제하기 위해 ES6에서 도입된 모듈을 사용할 수도 있다. 모던 브라우저에서 ES6 모듈을 사용할 수 있다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/02/%EC%8A%A4%EC%BD%94%ED%94%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/%EC%8A%A4%EC%BD%94%ED%94%84/" class="post-title-link" itemprop="url">Scope</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-26 20:04:06 / Modified: 23:10:50" itemprop="dateCreated datePublished" datetime="2020-02-26T20:04:06+09:00">2020-02-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-스코프"><a href="#1-스코프" class="headerlink" title="1.스코프"></a>1.스코프</h2><p>스코프는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념이다. 스코프는 변수 그리고 함수와 깊은 관련이 있다.<br>함수의 매개변수는 함수 몸체 내부에서만 참조할 수 있다. 그러므로 매개변수의 스코프는 함수 몸체 내부이다.<br>모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다. 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야 할 것인지를 결정한다. 즉, 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이다.</p>
<hr>
<h2 id="2-스코프의-종류"><a href="#2-스코프의-종류" class="headerlink" title="2. 스코프의 종류"></a>2. 스코프의 종류</h2><ul>
<li>코드의 전역(global)과 지역(local) 구분<ul>
<li>전역은 코드의 가장 바깥 영역으로 전역 스코프, 전역 변수가 있다.</li>
<li>지역은 함수 몸체 내부로 지역 스코프, 지역 변수가 있다.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-1-전역과-전역-스코프"><a href="#2-1-전역과-전역-스코프" class="headerlink" title="2-1. 전역과 전역 스코프"></a>2-1. 전역과 전역 스코프</h3><p>전역은 코드의 가장 바깥 영역을 말한다. 전역은 전역 스코프를 만든다. 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 된다. 전역 변수는 어디서든지 참조할 수 있다.</p>
<hr>
<h3 id="2-2-지역과-지역-스코프"><a href="#2-2-지역과-지역-스코프" class="headerlink" title="2-2. 지역과 지역 스코프"></a>2-2. 지역과 지역 스코프</h3><p>지역이란 함수 몸체 내부를 말한다. 지역은 지역 스코프를 만든다. 지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수가 된다. 지역 변수는 자신이 선언된 지역과 하위 지역에서만 참조할 수 있다. 다시 말해 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.</p>
<hr>
<h2 id="3-스코프-체인"><a href="#3-스코프-체인" class="headerlink" title="3. 스코프 체인"></a>3. 스코프 체인</h2><p>함수 몸체 내부에서 함수가 정의된 것을 함수의 중첩이라 한다. 그리고 함수 몸체 내부에서 정의한 함수를 중첩 함수, 중첩 함수를 포함하는 외부 함수라고 부른다. 함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다. 이는 스코프의 함수의 중첩에 의해 계층적 구조를 갖는다는 것을 의미한다. 모든 스코프는 하나의 계층적 구조로 연결되며 모든 지역 스코프의 최상위 스코프는 전역 스코프이다. 이렇게 스코프가 계층적으로 연결된 것을 스코프 체인이라 부른다. 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 이를 통해 상위 스코에서 선언한 변수를 하위 스코프에서도 참조할 수 있다.</p>
<hr>
<h3 id="3-1-스코프-체인에-의한-변수-검색"><a href="#3-1-스코프-체인에-의한-변수-검색" class="headerlink" title="3-1. 스코프 체인에 의한 변수 검색"></a>3-1. 스코프 체인에 의한 변수 검색</h3><p>자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 절대 하위 스코프로 내려가면 식별자를 검색하는 일은 없다. 이는 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다는 것을 의미한다.</p>
<hr>
<h3 id="3-2-스코프-체인에-의한-함수-검색"><a href="#3-2-스코프-체인에-의한-함수-검색" class="headerlink" title="3-2. 스코프 체인에 의한 함수 검색"></a>3-2. 스코프 체인에 의한 함수 검색</h3><p>자바스크립트 엔진은 함수 이름과 동일한 이름의 변수를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.<br>함수도 변수에 할당되기 때문에 스코프를 갖는다. 함수는 변수에 함수 객체가 할당된 것 외에는 일반 변수와 다를 바가 없다. 따라서 스코프는 식별자를 검색하는 규칙이라고 표현하는 것이 보다 적합하다.</p>
<hr>
<h2 id="4-함수-레벨-스코프"><a href="#4-함수-레벨-스코프" class="headerlink" title="4. 함수 레벨 스코프"></a>4. 함수 레벨 스코프</h2><p>지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다고 했다. 이는 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 의미이다. var키워드로 선언된 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다. 이러한 특성을 함수 레벨 스코프라 한다.</p>
<hr>
<h2 id="5-레시컬-스코프"><a href="#5-레시컬-스코프" class="headerlink" title="5. 레시컬 스코프"></a>5. 레시컬 스코프</h2><p>함수를 어디서 호출했는지와 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.<br>함수 정의 시점에서 함수가 어디서 호출될 지 알 수 없다. 따라서 함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프라고 부른다.<br>동적 스코프 방식처럼 상위 스코프가 동적으로 변하지 않고 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프라고 부른다. 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/02/%ED%95%A8%EC%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/%ED%95%A8%EC%88%98/" class="post-title-link" itemprop="url">function</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-26 17:05:02 / Modified: 20:02:49" itemprop="dateCreated datePublished" datetime="2020-02-26T17:05:02+09:00">2020-02-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-함수"><a href="#1-함수" class="headerlink" title="1. 함수"></a>1. 함수</h2><p>함수는 자바스크립트에서 가장 중요한 핵심 개념이다. 그리고 함수는 마치 재료를 투입받아서 제품을 생산하는 기계와 같다. 프로그래밍 언어의 함수는 일련의 과정을 문들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다. 프로그래밍 언어의 함수도 입력을 받아서 출력을 내보낸다. 이때 함수 내부로 입력을 전달받는 변수를 매개변수, 입력을 인수, 출력을 반환값이라 한다. 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다.</p>
<hr>
<h2 id="2-함수의-사용-이유"><a href="#2-함수의-사용-이유" class="headerlink" title="2. 함수의 사용 이유"></a>2. 함수의 사용 이유</h2><p>함수는 필요 할 때 몇 번이든 호출할 수 있으므로 코드의 재사용할 수 있어 매우 유용하다. 함수는 코드의 중복을 억제하고 재사용성을 높인다. 그리고 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다. 함수는 객체 타입의 값이다. 따라서 식별자을 붙일 수 있어 코드의 가독성을 향상시킨다.</p>
<hr>
<h2 id="3-함수-리터럴"><a href="#3-함수-리터럴" class="headerlink" title="3. 함수 리터럴"></a>3. 함수 리터럴</h2><p>함수 리터럴로 함수를 생성할 수 있다. 함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록 그리고 함수 몸체로 구성된다.</p>
<ul>
<li><p>함수 이름</p>
<ul>
<li>함수 이름은 식별자이다. 따라서 식별자 네이밍 규칙을 준수해야 한다.</li>
<li>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.</li>
<li>함수 이름은 생략할 수 있다. 이름이 있는 함수를 기명 함수, 함수 이름이 없는 함수를 익명 함수라 한다.</li>
</ul>
</li>
<li><p>매개변수 목록</p>
<ul>
<li>0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다.</li>
<li>매개변수에는 함수호출문의 인수가 순서대로 할당된다. 즉, 매개변수 목록은 순서에 의미가 있다.</li>
<li>매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다.</li>
</ul>
</li>
<li><p>함수 몸체</p>
<ul>
<li>함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.</li>
<li>함수 몸체는 함수 호출에 의해 실행된다.</li>
</ul>
</li>
</ul>
<p>함수는 객체이지만 일반 객체는 호출할 수 없지만 함수는 호출할 수 있고 함수 객체만의 고유한 프로퍼티를 갖는다.</p>
<hr>
<h2 id="4-함수-정의"><a href="#4-함수-정의" class="headerlink" title="4. 함수 정의"></a>4. 함수 정의</h2><p>함수 정의란 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행한 문들, 그리고 반환할 값을 지정하는 것을 말한다. 즉, 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.</p>
<ul>
<li>함수를 정의하는 4가지 방법<ul>
<li>함수 선언문</li>
<li>함수 표현식</li>
<li>Function 생성자 함수</li>
<li>화살표 함수: ES6</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-1-함수-선언문"><a href="#4-1-함수-선언문" class="headerlink" title="4-1. 함수 선언문"></a>4-1. 함수 선언문</h3><p>함수 선언문은 함수 리터럴과 형태가 동일 하지만 함수 선언문은 함수 이름을 생략할 수 없다.</p>
<hr>
<h3 id="4-2-함수-표현식"><a href="#4-2-함수-표현식" class="headerlink" title="4-2. 함수 표현식"></a>4-2. 함수 표현식</h3><p>자바스크립트의 함수는 일급 객체이다. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다. 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식이라 한다. 함수 리터럴의 함수 이름은 생략할 수 있다.</p>
<hr>
<h3 id="4-3-함수-생성-시점과-함수-호이스팅"><a href="#4-3-함수-생성-시점과-함수-호이스팅" class="headerlink" title="4-3. 함수 생성 시점과 함수 호이스팅"></a>4-3. 함수 생성 시점과 함수 호이스팅</h3><p>함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다. 함수 호이스팅은 코드가 한줄씩 순차적으로 실행되기 시작하는 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태다. 따라서 함수선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있다.</p>
<hr>
<h3 id="4-4-Function-생성자-함수"><a href="#4-4-Function-생성자-함수" class="headerlink" title="4-4. Function 생성자 함수"></a>4-4. Function 생성자 함수</h3><p>Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성하여 반환한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">생성자 함수는 객체를 생성하는 함수를 말한다.</span><br></pre></td></tr></table></figure>
<p>Function 생성자 함수는 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.</p>
<hr>
<h3 id="4-5-화살표-함수"><a href="#4-5-화살표-함수" class="headerlink" title="4-5. 화살표 함수"></a>4-5. 화살표 함수</h3><p>화살표 함수는 function 키워드 대신 화살표(=&gt;)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다. 화살표 함수는 익명 함수로 정의한다.</p>
<hr>
<h2 id="5-함수-호출"><a href="#5-함수-호출" class="headerlink" title="5. 함수 호출"></a>5. 함수 호출</h2><p>함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다. 함수 호출 연산자 내에는 0개 이상의 인수를 쉼표로 구분하여 나열한다. 그리고 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행되기 시작한다.</p>
<hr>
<h3 id="5-1-메게변수와-인수"><a href="#5-1-메게변수와-인수" class="headerlink" title="5-1. 메게변수와 인수"></a>5-1. 메게변수와 인수</h3><p>함수의 실행을 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우, 매개변수를 통해 인수를 전달한다. 인수는 표현식이어야 하며 인수는 함수를 호출할 때 지정하며 개수와 타입에 제한이 없다.</p>
<hr>
<h3 id="5-2-인수-확인"><a href="#5-2-인수-확인" class="headerlink" title="5-2. 인수 확인"></a>5-2. 인수 확인</h3><p>자바스크립트의 경우, 함수를 정의할 때 적절한 인수가 전달되었는지 확인이 필요한다.</p>
<hr>
<h3 id="5-3-매개변수의-최대-개수"><a href="#5-3-매개변수의-최대-개수" class="headerlink" title="5-3. 매개변수의 최대 개수"></a>5-3. 매개변수의 최대 개수</h3><p>이상적인 매개변수 개수는 0개이며 적을 수록 좋다. 따라서 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다.</p>
<hr>
<h3 id="5-4-반환문"><a href="#5-4-반환문" class="headerlink" title="5-4. 반환문"></a>5-4. 반환문</h3><p>함수는 return 키워드와 반환값으로 이루어진 반환문을 사용하여 실해 결과를 함수 외부로 반환할 수 있다. </p>
<ul>
<li>반환문의 두가지 역할<ul>
<li><ol>
<li>반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.</li>
</ol>
</li>
<li><ol start="2">
<li>반환문은 return 키워드 뒤에 지정한 값을 반환한다.</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="6-참조에-의한-전달과-외부-상태의-변경"><a href="#6-참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="6. 참조에 의한 전달과 외부 상태의 변경"></a>6. 참조에 의한 전달과 외부 상태의 변경</h2><p>매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 한다.<br>매개변수에 값을 전달하는 방식을 값에 의한 호출, 참조에 의한 호출로 구별해 부르는 경우도 있다.</p>
<hr>
<h2 id="7-다양한-함수의-형태"><a href="#7-다양한-함수의-형태" class="headerlink" title="7. 다양한 함수의 형태"></a>7. 다양한 함수의 형태</h2><h3 id="7-1-즉시실행함수"><a href="#7-1-즉시실행함수" class="headerlink" title="7-1. 즉시실행함수"></a>7-1. 즉시실행함수</h3><p>함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 한다. 즉시 실행 함수는 한번만 호출되며 함수 이름이 없는 익명 함수를 사용할 수 있고, 함수 이름이 있는 기명 즉시 실행 함수도 사용할 수 있다. 기명 즉시 실행 함수는 함수 리터럴로 평가되며 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자이므로 즉시 실행 함수를 다시 호출할 수는 없다. 그러므로 즉시 실행 함수는 반드시 그룹 연산자로 감싸 주어야 한다.</p>
<hr>
<h3 id="7-2-재귀-함수"><a href="#7-2-재귀-함수" class="headerlink" title="7-2. 재귀 함수"></a>7-2. 재귀 함수</h3><p>함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다.</p>
<hr>
<h3 id="7-3-중첩-함수"><a href="#7-3-중첩-함수" class="headerlink" title="7-3. 중첩 함수"></a>7-3. 중첩 함수</h3><p>함수 내부에 정의된 함수를 중첩 함수또는 내부 함수라 한다.</p>
<hr>
<h3 id="7-4-콜백-함수"><a href="#7-4-콜백-함수" class="headerlink" title="7-4. 콜백 함수"></a>7-4. 콜백 함수</h3><p>함수의 매개변수를 통해 전달되는 함수를 콜백 함수라고 하며,콜백 함수를 매개변수를 통해 전달받은 함수를 고차 함수라고 한다. 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다. 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시좀을 결정하여 호출한다.</p>
<hr>
<h3 id="7-5-순수-함수와-비순수-함수"><a href="#7-5-순수-함수와-비순수-함수" class="headerlink" title="7-5. 순수 함수와 비순수 함수"></a>7-5. 순수 함수와 비순수 함수</h3><p>함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 변경시키지도 않는, 즉 부수효과가 없는 함수를 순수 함수, 외부 상태를 변경시키는 즉, 부수 효과가 있는 함수를 비순수 함수라고 한다.<br>순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수를 말하고, 함수의 외부 상태를 변경하지 않는다.<br>비순수 함수는 함수의 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 함수이고, 외부 상태를 변경하는 부수 효과가 있다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/02/%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC%EA%B0%9D%EC%B2%B4%EC%9D%98%EB%B9%84%EA%B5%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC%EA%B0%9D%EC%B2%B4%EC%9D%98%EB%B9%84%EA%B5%90/" class="post-title-link" itemprop="url">Comparison of primitive values and objects</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-26 14:32:15 / Modified: 15:53:40" itemprop="dateCreated datePublished" datetime="2020-02-26T14:32:15+09:00">2020-02-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-원시-값"><a href="#1-원시-값" class="headerlink" title="1. 원시 값"></a>1. 원시 값</h2><h3 id="1-1-변경-불가능한-값"><a href="#1-1-변경-불가능한-값" class="headerlink" title="1-1. 변경 불가능한 값"></a>1-1. 변경 불가능한 값</h3><p>원시 값은 변경 불가능한 값이다. 즉 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다. 변수는 언제든지 재할당을 통해 변수 값을 변경 할 수 있다. 상수는 단 한번만 할당 할 수 있다. 따라서 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 원시 값의 특성을 불변성이라 한다.</p>
<hr>
<h3 id="1-2-문자열과-불변성"><a href="#1-2-문자열과-불변성" class="headerlink" title="1-2. 문자열과 불변성"></a>1-2. 문자열과 불변성</h3><p>원시 값인 문자열은 다른 원시 값과 비교할 때 특징은 문자열은 0개 이상의 문자 들로 이루어진 집합을 말하며 1개의 문자는 2byte의 메모리 공간에 저장된다. 숫자 값은 1도, 1000000도 8byte가 필요하다.</p>
<hr>
<h3 id="1-3-값에-의한-전달"><a href="#1-3-값에-의한-전달" class="headerlink" title="1-3. 값에 의한 전달"></a>1-3. 값에 의한 전달</h3><p>변수에 원시값을 갖는 변수를 할당하면 변수에는 할당되는 변수의 원시값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 두개의 값은 다른 메모리 공간에 저장된 별개의 값이 된다. 값의 의한 전달도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다. 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다. 변수에 원시값을 갖는 변수를 할당하는 경우, 두 변수의 원시값은 거로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.</p>
<hr>
<h2 id="2-객체"><a href="#2-객체" class="headerlink" title="2. 객체"></a>2. 객체</h2><p>객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다.</p>
<hr>
<h3 id="2-1-변경-가능한-값"><a href="#2-1-변경-가능한-값" class="headerlink" title="2-1. 변경 가능한 값"></a>2-1. 변경 가능한 값</h3><p>객체는 변경 가능한 값이다. 객체를 할당한 변수에는 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장되어 있다. 이 값을 참조 값이라고 한다. 변수는 이 참조 값을 통해 객체에 접근 한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">얕은 복사는 한 단계까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.</span><br></pre></td></tr></table></figure>
<p>객체는 이러한 구조적 단점에 따른 부작용이 있다. 그것은 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다.</p>
<hr>
<h3 id="2-2-참조에-의한-전달"><a href="#2-2-참조에-의한-전달" class="headerlink" title="2-2. 참조에 의한 전달"></a>2-2. 참조에 의한 전달</h3><p>객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.<br>자바스크립트에는 참조에 의한 전달은 존재하지 않고 값에 의한 전달 만이 존재한다고 말할 수 있다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/02/%EA%B0%9D%EC%B2%B4%EB%A6%AC%ED%84%B0%EB%9F%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/%EA%B0%9D%EC%B2%B4%EB%A6%AC%ED%84%B0%EB%9F%B4/" class="post-title-link" itemprop="url">Object literal</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-24 19:37:30 / Modified: 20:07:05" itemprop="dateCreated datePublished" datetime="2020-02-24T19:37:30+09:00">2020-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-객체"><a href="#1-객체" class="headerlink" title="1. 객체"></a>1. 객체</h2><p>자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 객체이다. 원시 값을 제외한 나머지 값들은 모두 객체이다. 객체는 변경 가능한 값이다. 자바스크립트의 객체는 키과 값으로 구성된 프로퍼티들의 집합이다.</p>
<ul>
<li>프로퍼티: 객체의 상태를 나타내는 값</li>
<li>메소드: 프로퍼티를 참조하고 조작할 수 있는 동작</li>
</ul>
<hr>
<h2 id="2-객체-리터럴에-의한-객체-생성"><a href="#2-객체-리터럴에-의한-객체-생성" class="headerlink" title="2. 객체 리터럴에 의한 객체 생성"></a>2. 객체 리터럴에 의한 객체 생성</h2><p>자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반 객체지향 언어와는 다른 다양한 객체 생성 방법이 존재한다.</p>
<ul>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create 메소드</li>
<li>클래스</li>
</ul>
<p>객체 생성 방법 중에서 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법이다. 객체 리터럴은 객체를 생성하는 표기법이다. 객체 리터럴은 중괄호({…}) 내에 0개 이상의 프로퍼티를 정의한다. 객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다. 객체 리터럴은 값으로 평가되는 표현식이다. 따라서 객체 리터럴의 닫는 중괄호 뒤에는 ; 붙인다.</p>
<hr>
<h2 id="3-프로퍼티"><a href="#3-프로퍼티" class="headerlink" title="3. 프로퍼티"></a>3. 프로퍼티</h2><p>객체는 프로퍼티들의 집합이며 프로퍼티는 키과 값으로 구성된다.<br>프로퍼티를 나열할 때는 쉼표(,)로 구분한다.<br>프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은</p>
<ul>
<li>프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 symbol 값</li>
<li>프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값</li>
</ul>
<p>프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자 역할을 한다. 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용한다.</p>
<hr>
<h2 id="4-메소드"><a href="#4-메소드" class="headerlink" title="4. 메소드"></a>4. 메소드</h2><p>자바스크립트에서 사용할 수 있는 모든 값을 프로퍼티 값으로 사용할 수 있다고 했다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드라 부른다. 메소드는 객체에 제한되어 있는 함수를 의미한다.</p>
<hr>
<h2 id="5-프로퍼티-접근"><a href="#5-프로퍼티-접근" class="headerlink" title="5. 프로퍼티 접근"></a>5. 프로퍼티 접근</h2><p>프로퍼티 값에 접근하려면 마침표(.)를 사용하는 마침표 표기법 또는 대괄호([…])를 사용하는 대괄호 표기법을 사용한다. 마침표 또는 대괄호의 좌측에는 객체로 평가할 수 있는 표현식을 기술한다. 마침표의 우측 또는 대괄호의 내부에는 프로퍼티 키를 지정한다. 대괄호 표기법 사용하는 경우, 대괄호 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.</p>
<hr>
<h2 id="6-프로퍼티-값-갱신"><a href="#6-프로퍼티-값-갱신" class="headerlink" title="6. 프로퍼티 값 갱신"></a>6. 프로퍼티 값 갱신</h2><p>프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.</p>
<hr>
<h2 id="7-프로퍼티-동적-생성"><a href="#7-프로퍼티-동적-생성" class="headerlink" title="7. 프로퍼티 동적 생성"></a>7. 프로퍼티 동적 생성</h2><p>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당한다.</p>
<hr>
<h2 id="8-프로퍼티-삭제"><a href="#8-프로퍼티-삭제" class="headerlink" title="8. 프로퍼티 삭제"></a>8. 프로퍼티 삭제</h2><p>delete 연산자는 객체의 프로퍼티를 삭제한다. delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다.</p>
<hr>
<h2 id="9-객체-리터럴의-확장-기능"><a href="#9-객체-리터럴의-확장-기능" class="headerlink" title="9. 객체 리터럴의 확장 기능"></a>9. 객체 리터럴의 확장 기능</h2><p>더욱 간편하고 표현력 있는 객체 리터럴의 확장 기능을 제공한다.</p>
<hr>
<h3 id="9-1-프로퍼티-축약-표현"><a href="#9-1-프로퍼티-축약-표현" class="headerlink" title="9-1. 프로퍼티 축약 표현"></a>9-1. 프로퍼티 축약 표현</h3><p>객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다. 프로퍼티의 값은 변수 할당된 값, 즉 식별자 표현식일 수도 있다. ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 프로퍼티 키는 변수 이름으로 자동 생성된다.</p>
<hr>
<h3 id="9-2-프로퍼티-키-동적-생성"><a href="#9-2-프로퍼티-키-동적-생성" class="headerlink" title="9-2. 프로퍼티 키 동적 생성"></a>9-2. 프로퍼티 키 동적 생성</h3><p>문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다. 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다. 이를 계산된 프로퍼티 이름이라 한다.</p>
<hr>
<h3 id="9-3-메소드-축약-표현"><a href="#9-3-메소드-축약-표현" class="headerlink" title="9-3. 메소드 축약 표현"></a>9-3. 메소드 축약 표현</h3><p>ES5에서 메소드를 정의하려면 프로퍼티 값으로 함수를 할당한다. ES6에서는 메소드를 정의할 때, function 키워드를 생략한 축약 표현을 사용할 수 있고 프로퍼티에 할당한 함수와 다르게 동작한다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/02/%ED%83%80%EC%9E%85%EB%B3%80%ED%99%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/%ED%83%80%EC%9E%85%EB%B3%80%ED%99%98/" class="post-title-link" itemprop="url">Type conversion and Short-Circuit evaluation</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-24 18:52:50 / Modified: 19:37:00" itemprop="dateCreated datePublished" datetime="2020-02-24T18:52:50+09:00">2020-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-타입변환"><a href="#1-타입변환" class="headerlink" title="1. 타입변환"></a>1. 타입변환</h2><p>자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 의해 다른 타입으로 변환 된다. 개발자의 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 한다. 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 암묵적 타입 변환 또는 타입 강제 변환이라고 한다.</p>
<hr>
<h2 id="2-암묵적-타입-변환"><a href="#2-암묵적-타입-변환" class="headerlink" title="2. 암묵적 타입 변환"></a>2. 암묵적 타입 변환</h2><p>암묵적으로 데이터 타입을 강제 변환 할 때가 있다. 즉, 암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다. </p>
<hr>
<h3 id="2-1-문자열-타입으로-변환"><a href="#2-1-문자열-타입으로-변환" class="headerlink" title="2-1. 문자열 타입으로 변환"></a>2-1. 문자열 타입으로 변환</h3><p>문자열 연결 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모든 피연산자는 모두 문자열 타입이어야 한다. 자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 피연산자를 문자열 타입으로 암묵적 타입 변환한다.</p>
<hr>
<h3 id="2-2-숫자-타입으로-변환"><a href="#2-2-숫자-타입으로-변환" class="headerlink" title="2-2. 숫자 타입으로 변환"></a>2-2. 숫자 타입으로 변환</h3><p>산술 연산자의 역할은 숫자 값을 만드는 것이다. 따라서 산술 연산자의 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이어야 한다. 자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 평가 결과는 NaN이 된다. </p>
<hr>
<h3 id="2-3-불리언-타입으로-변환"><a href="#2-3-불리언-타입으로-변환" class="headerlink" title="2-3. 불리언 타입으로 변환"></a>2-3. 불리언 타입으로 변환</h3><p>if 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 논리적 참, 거짓을 반환해야 하는 표현식이다. 자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다. 이때 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값 또는 Falsy 값으로 구분한다.</p>
<ul>
<li>false로 평가되는 Falsy 값<ul>
<li>flase</li>
<li>undefined</li>
<li>null</li>
<li>0, -0</li>
<li>NaN</li>
<li>“(빈문자열)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-명시적-타입-변환"><a href="#3-명시적-타입-변환" class="headerlink" title="3. 명시적 타입 변환"></a>3. 명시적 타입 변환</h2><p>명시적으로 타입 변경하는 방법은 표준 빌트인 생성자 함수를 new연산자 없이 호출하는 방법과 자바스크립트에서 제공하는 빌트인 메소드를 사용하는 방법, 암묵적 타입 변환을 이용하는 방법이 있다.</p>
<hr>
<h3 id="3-1-문자열-타입으로-변환"><a href="#3-1-문자열-타입으로-변환" class="headerlink" title="3-1. 문자열 타입으로 변환"></a>3-1. 문자열 타입으로 변환</h3><p>문자열 타입이 아닌 값을 문자열 타입으로 변환 방법</p>
<ul>
<li>string 생성자 함수를 new 연산자 없이 호출하는 방법</li>
<li>Object.prototype.toString 메소드를 사용하는 방법</li>
<li>문자열 연결 연산자를 이용하는 방법</li>
</ul>
<hr>
<h3 id="3-2-숫자-타입으로-변환"><a href="#3-2-숫자-타입으로-변환" class="headerlink" title="3-2. 숫자 타입으로 변환"></a>3-2. 숫자 타입으로 변환</h3><p>숫자 타입이 아닌 값을 숫자 타입으로 변환 방법</p>
<ul>
<li>Number 생성자 함수를 new 연산자 없이 호출하는 방법</li>
<li>parseInt, parseFloat 함수를 사용하는 방법</li>
<li>+단항 산술 연산자를 이용하는 방법</li>
<li>*산술 연산자를 이용하는 방법</li>
</ul>
<hr>
<h3 id="3-3-불리언-타입으로-변환"><a href="#3-3-불리언-타입으로-변환" class="headerlink" title="3-3. 불리언 타입으로 변환"></a>3-3. 불리언 타입으로 변환</h3><p>불리언 타입이 아닌 값을 불리언 타입으로 변환 방법</p>
<ul>
<li>Boolean 생성자 함수를 new 연산자 없이 호출하는 방법</li>
<li>!부정 논리 연산자를 두번 사용하는 방법</li>
</ul>
<hr>
<h2 id="4-단축-평가"><a href="#4-단축-평가" class="headerlink" title="4. 단축 평가"></a>4. 단축 평가</h2><p>논리 연산의 결과를 결정한 타입 변환하지 않고 피연산자를 그대로 반환한다.이를 단축 평가라 부른다. 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단하는 것이다.</p>
<ul>
<li>단축 평가 표현식과 평가 결과<ul>
<li>true || anything = ture</li>
<li>false || anything = anything</li>
<li>true &amp;&amp; anything = anything</li>
<li>false &amp;&amp; anything = false</li>
</ul>
</li>
</ul>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/02/%EC%A0%9C%EC%96%B4%EB%AC%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/%EC%A0%9C%EC%96%B4%EB%AC%B8/" class="post-title-link" itemprop="url">Control flow statement</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-23 17:49:38 / Modified: 18:20:40" itemprop="dateCreated datePublished" datetime="2020-02-23T17:49:38+09:00">2020-02-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="제어문"><a href="#제어문" class="headerlink" title="제어문"></a>제어문</h2><p>제어문은 주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 일반적 으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.</p>
<hr>
<h3 id="1-블록문"><a href="#1-블록문" class="headerlink" title="1. 블록문"></a>1. 블록문</h3><p>블록문는 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다. 블록문은 단독으로 사용할 수도 있으나 일반적으로 제어문이나 함수를 정의할 때 사용하는 것이 일반적이다.</p>
<hr>
<h3 id="2-조건문"><a href="#2-조건문" class="headerlink" title="2. 조건문"></a>2. 조건문</h3><p>조건문은 주어진 조건식의 평가 결과에 따라 코드 블럭의 실행을 결정한다. 조건식은 불리언 값으로 평가될 수 있는 표현식이다. 2가지의 조건문 if…else 문과 switch 문을 제공한다.</p>
<hr>
<h3 id="2-1-if…else-문"><a href="#2-1-if…else-문" class="headerlink" title="2-1. if…else 문"></a>2-1. if…else 문</h3><p>if…else 문은 주어진 조건식의 평가 결과, 즉 논리적 참 또는 거짓에 따라 실행할 코드 블록을 결정한다. 조건식의 평가 결과가 참일 경우, if 문 다음의 코드 블록이 실행되고 거짓일 경우, else 문 다음의 코드 블록이 실행된다.<br>if 문의 조건식은 불리언 값으로 평가되어야 한다.</p>
<hr>
<h3 id="2-2-switch-문"><a href="#2-2-switch-문" class="headerlink" title="2-2. switch 문"></a>2-2. switch 문</h3><p>switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 순서를 이동시킨다. case 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다.</p>
<hr>
<h3 id="3-반복문"><a href="#3-반복문" class="headerlink" title="3. 반복문"></a>3. 반복문</h3><p>반복문은 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참 인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다.<br>가지의 반복문 for 문, while 문, do…while 문을 제공한다.</p>
<hr>
<h3 id="3-1-for-문"><a href="#3-1-for-문" class="headerlink" title="3-1. for 문"></a>3-1. for 문</h3><p>for 문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다.</p>
<hr>
<h3 id="3-2-while-문"><a href="#3-2-while-문" class="headerlink" title="3-2. while 문"></a>3-2. while 문</h3><p>while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 실행을 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별한다.</p>
<hr>
<h3 id="3-3-do…while-문"><a href="#3-3-do…while-문" class="headerlink" title="3-3. do…while 문"></a>3-3. do…while 문</h3><p>do…while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한번 이상 실행된다.</p>
<hr>
<h3 id="4-break-문"><a href="#4-break-문" class="headerlink" title="4. break 문"></a>4. break 문</h3><p>switch 문과 while 문에서 살펴보았듯이 break 문은 코드 블록을 탈출한다. 좀 더 정확히 표현하자면 코드 블록을 탈출하는 것이 아니라 레이블 문, 반복문 또는 switch 문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 이외에 break 문을 사용하면 SyntaxError가 발생한다.</p>
<hr>
<h3 id="5-continue-문"><a href="#5-continue-문" class="headerlink" title="5. continue 문"></a>5. continue 문</h3><p>continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다. break 문처럼 반복문을 탈출하지는 않는다. </p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/02/%EC%97%B0%EC%82%B0%EC%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/%EC%97%B0%EC%82%B0%EC%9E%90/" class="post-title-link" itemprop="url">Operator</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-22 20:29:20" itemprop="dateCreated datePublished" datetime="2020-02-22T20:29:20+09:00">2020-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-23 17:40:26" itemprop="dateModified" datetime="2020-02-23T17:40:26+09:00">2020-02-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h2><hr>
<p>연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자라 한다.</p>
<hr>
<h3 id="1-산술-연산자"><a href="#1-산술-연산자" class="headerlink" title="1. 산술 연산자"></a>1. 산술 연산자</h3><p>산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.</p>
<hr>
<h3 id="1-1-이항-산술-연산자"><a href="#1-1-이항-산술-연산자" class="headerlink" title="1-1. 이항 산술 연산자"></a>1-1. 이항 산술 연산자</h3><p>이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다.</p>
<ul>
<li>이항 산술 연산자 종류의 의미와 부수 효과<ul>
<li>덧셈(+) 부수효과가 없음.</li>
<li>뺄셈(-) 부수효과가 없음.</li>
<li>곱셈(*) 부수효과가 없음.</li>
<li>나눗셈(/) 부수효과가 없음.</li>
<li>나머지(%) 부수효과가 없음.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-단항-산술-연산자"><a href="#1-2-단항-산술-연산자" class="headerlink" title="1-2. 단항 산술 연산자"></a>1-2. 단항 산술 연산자</h3><p>단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다.<br>증가/감소 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.</p>
<ul>
<li>단항 산술 연산자 종류의 의미와 부수 효과<ul>
<li>증가(++) 부수효과가 있음.</li>
<li>감소(–) 부수효과가 있음.</li>
<li>덧셈은 어떤한 효과도 없다.</li>
<li>뺄셈은 양수를 음수로 음수를 양수로 반전한 값을 반환한다.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-문자열-연결-연산자"><a href="#1-3-문자열-연결-연산자" class="headerlink" title="1-3. 문자열 연결 연산자"></a>1-3. 문자열 연결 연산자</h3><p>덧셈 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.</p>
<hr>
<h3 id="2-할당-연산자"><a href="#2-할당-연산자" class="headerlink" title="2. 할당 연산자"></a>2. 할당 연산자</h3><p>할당 연산자는 우항에 있는 피연자의 평가 결과를 좌항에 있는 변수에 할당한다.</p>
<ul>
<li>할당 연산자 종류의 사례와 동일 표현과 부수 효과<ul>
<li>=는  x = 5 or x = 5,  부수 효과가 있음.</li>
<li>+=는 x += 5 or x = x + 5, 부수 효과가 있음.</li>
<li>-=는 x -= 5 or x = x - 5, 부수 효과가 있음.</li>
<li>*=는 x *= 5 or x = x * 5, 부수 효과가 있음.</li>
<li>/=는 x /= 5 or x = x / 5, 부수 효과가 있음.</li>
<li>%=는 x %= 5 or x = x % 5, 부수 효과가 있음.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-비교-연산자"><a href="#3-비교-연산자" class="headerlink" title="3. 비교 연산자"></a>3. 비교 연산자</h3><p>비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다. 비교 연산자는 if문이나 for문과 같은 제어문의 조건식에서 주로 사용한다. 비교 연산자는 동등/일치 비교 연산자와 대소 관계 비교 연산자로 나뉜다.</p>
<hr>
<h3 id="3-1-동등-일치-비교-연산자"><a href="#3-1-동등-일치-비교-연산자" class="headerlink" title="3-1. 동등/일치 비교 연산자"></a>3-1. 동등/일치 비교 연산자</h3><p>동등 비교 연산와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값을 갖는지 비교하여 불리언 값을 반환한다. 하지만 동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다.</p>
<ul>
<li>동등/일치 비교 연산자 종류의 의미, 사례, 설명, 부수효과<ul>
<li>동등 비교(==)는 x == y 즉, x와 y의 값이 같음, 부수 효과 없음.</li>
<li>일치 비교(===)는 x === y 즉, x와 y의 값과 타입이 같음, 부수 효과 없음.</li>
<li>부동등 비교(!=)는 x != y 즉, x와 y의 값이 다름, 부수 효과 없음.</li>
<li>불일치 비교(!==)는 x !== y 즉, x와 y의 값과 타입이 다름, 부수 효과 없음.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-대소-관계-비교-연산자"><a href="#3-2-대소-관계-비교-연산자" class="headerlink" title="3-2. 대소 관계 비교 연산자"></a>3-2. 대소 관계 비교 연산자</h3><p>대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.</p>
<ul>
<li>대소 관계 비교 연산자 종류의 예제, 설명, 부수효과<ul>
<li>(&gt;)는 x &gt; y 즉, x가 y보다 크다, 부수 효과 없음.</li>
<li>(&lt;)는 x &lt; y 즉, x가 y보다 작다, 부수 효과 없음.</li>
<li>(&gt;=)는 x &gt;= y 즉, x가 y보다 같거나 크다, 부수 효과 없음.</li>
<li>(&lt;=)는 x &lt;= y 즉, x가 y보다 같거나 크다, 부수 효과 없음.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-삼항-조건-연산자"><a href="#4-삼항-조건-연산자" class="headerlink" title="4. 삼항 조건 연산자"></a>4. 삼항 조건 연산자</h3><p>삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다. 자바스크립트의 유일한 삼항 연산자는 부수 효과는 없다. 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다.</p>
<hr>
<h3 id="5-논리-연산자"><a href="#5-논리-연산자" class="headerlink" title="5. 논리 연산자"></a>5. 논리 연산자</h3><p>논리 연산자는 우항과 좌항의 피연산자를 논리 연산한다.</p>
<ul>
<li>논리 연산자 종류의 의미와 부수 효과<ul>
<li>||는 논리합(OR)이고, 부수 효과 없음.</li>
<li>&amp;&amp;는 논리곱(AND)이고, 부수 효과 없음.</li>
<li>!는 부정(NOT)이고, 부수 효과 없음.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-쉼표-연산자"><a href="#6-쉼표-연산자" class="headerlink" title="6. 쉼표 연산자"></a>6. 쉼표 연산자</h3><p>쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.</p>
<hr>
<h3 id="7-그룹-연산자"><a href="#7-그룹-연산자" class="headerlink" title="7. 그룹 연산자"></a>7. 그룹 연산자</h3><p>그룹 연산자(…)는 피연산자인 표현식을 가장 먼저 평가한다. 따라서 그룹 연산자를 사용하면 연산자의 우선 순위를 조절할 수 있다.</p>
<hr>
<h3 id="8-typeof-연산자"><a href="#8-typeof-연산자" class="headerlink" title="8. typeof 연산자"></a>8. typeof 연산자</h3><p>typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자는 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환한다. “null”을 반환하는 경우는 없으며 함수의 경우 “function”을 반환한다. </p>
<hr>
<h3 id="9-지수-연산자"><a href="#9-지수-연산자" class="headerlink" title="9. 지수 연산자"></a>9. 지수 연산자</h3><p>ES7에서 새롭게 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다.</p>
<hr>
<h3 id="10-연산자의-부수-효과"><a href="#10-연산자의-부수-효과" class="headerlink" title="10. 연산자의 부수 효과"></a>10. 연산자의 부수 효과</h3><p>대부분의 연산자는 다른 코드에 영향을 주지 않는다. 예를 들어, 1 * 2는 다른 코드에 어떤한 영향도 주지 않는다.하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wgy5446</p>
  <div class="site-description" itemprop="description">All story about js</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wgy5446</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
