<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wgy5446.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="All story about js">
<meta property="og:type" content="website">
<meta property="og:title" content="John">
<meta property="og:url" content="https://wgy5446.github.io/index.html">
<meta property="og:site_name" content="John">
<meta property="og:description" content="All story about js">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="wgy5446">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content=" js">
<meta property="article:tag" content=" react">
<meta property="article:tag" content=" anqular">
<meta property="article:tag" content=" hhkb">
<meta property="article:tag" content=" realforce">
<meta property="article:tag" content=" leopold">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wgy5446.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>John</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">John</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">John</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/03/%ED%81%B4%EB%9E%98%EC%8A%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/%ED%81%B4%EB%9E%98%EC%8A%A4/" class="post-title-link" itemprop="url">클래스</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-18 19:17:08" itemprop="dateCreated datePublished" datetime="2020-03-18T19:17:08+09:00">2020-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-19 01:04:05" itemprop="dateModified" datetime="2020-03-19T01:04:05+09:00">2020-03-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-클래스는-프로토타입의-문법적-설탕인가"><a href="#1-클래스는-프로토타입의-문법적-설탕인가" class="headerlink" title="1. 클래스는 프로토타입의 문법적 설탕인가?"></a>1. 클래스는 프로토타입의 문법적 설탕인가?</h2><p>클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕이라고 볼 수도 있다.</p>
<p>클래스는 생성자 함수와 매우 유사하게 동작하지만 몇가지 차이가 있다.</p>
<ol>
<li><p>클래스는 new 연산자를 사용하지 않고 호출하면 에러가 발행한다. 하지만 생성자 함수는 new  연산자를 사용하지 않고 호출하면 일반 함수로서 호출된다.</p>
</li>
<li><p>클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 하지만 생성자 함수는 extends와 super 키워드를 지원하지 않는다.</p>
</li>
<li><p>클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.</p>
</li>
<li><p>클래스 내의 모든 코드에는 암묵적으로 strict 모드가 지정되어 실행되며 strict 모드를 해지할 수 없다. 하지만 생성자 함수는 암묵적으로 strict 모드가 지정되지 않는다.</p>
</li>
<li><p>클래스의 constructor, 프로토타입 메소드, 정적 메소드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이다. 다시 말해, 열거되지 않는다.</p>
</li>
</ol>
<p>class를 새로운 객체 생성 메커니즘으로 보는 것이 합당하다.</p>
<hr>
<h2 id="2-클래스-정의"><a href="#2-클래스-정의" class="headerlink" title="2.클래스 정의"></a>2.클래스 정의</h2><p>클래스는 class 키워드를 사용하여 정의한다. 클래스 이름은 파스칼 케이스를 사용하는 것이 일반적이다.<br>일반적이지는 않지만, 함수와 마찬가지로 표현식으로 클래스를 정의 할 수도 있다.<br>클래스 몸체에는 0개 이상의 메소드만을 정의할 수 있다. 클래스 몸체에서 정의할 수 있는 메소드는 생성자, 프로토타입 메소드, 정적 메소드 3가지가 있다.</p>
<hr>
<h2 id="3-클래스-호이스팅"><a href="#3-클래스-호이스팅" class="headerlink" title="3. 클래스 호이스팅"></a>3. 클래스 호이스팅</h2><p>클래스는 클래스 정의 이전에 참조할 수 없다.<br>호이스팅이 발생하지만 발생하지 않는 것처럼 동작한다.</p>
<hr>
<h2 id="4-인스턴스-생성"><a href="#4-인스턴스-생성" class="headerlink" title="4. 인스턴스 생성"></a>4. 인스턴스 생성</h2><p>클래스는 함수로 평가된다.<br>클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다. new 없이 함수를 호출 하면 타입 에러가 발생한다.</p>
<hr>
<h2 id="5-메소드"><a href="#5-메소드" class="headerlink" title="5. 메소드"></a>5. 메소드</h2><p>클래스 몸체에는 0개 이상의 메소드 만을 선언할 수 있다. 클래스 몸체에는 constructor, 프로토타입 메소드, 정적 메소드 3가지가 있다.</p>
<h3 id="5-1-constructor"><a href="#5-1-constructor" class="headerlink" title="5-1. constructor"></a>5-1. constructor</h3><p>constructor는 인스턴스를 생성하고 초기화하기 위한 특수한 메소드이다.</p>
<h3 id="5-2-프로토타입-메소드"><a href="#5-2-프로토타입-메소드" class="headerlink" title="5-2. 프로토타입 메소드"></a>5-2. 프로토타입 메소드</h3><p>클래스 몸체에서 정의한 메소드는 생성자 함수에 의한 객체 생성 방식가는 다르게 클래스의 prototype 프로퍼티에 메소드를 추가하지 않아도 기본적으로 프로토타입이 메소드가 된다.</p>
<h3 id="5-3-정적-메소드"><a href="#5-3-정적-메소드" class="headerlink" title="5-3. 정적 메소드"></a>5-3. 정적 메소드</h3><p>정적메소드는 인스턴스를 생성하지 않아도 호출 할 수 있는 메소드를 말한다. 생성자 함수의 경우, 정적 메소드를 생성하기 위해서는 명시적으로 생성자 함수에 메소드를 추가해야 한다. 클래스에는 메소드에 static 키워드를 붙이면 정적 메소드가 된다.</p>
<h3 id="5-4-정적-메소드와-프로토타입-메소드의-차이"><a href="#5-4-정적-메소드와-프로토타입-메소드의-차이" class="headerlink" title="5-4. 정적 메소드와 프로토타입 메소드의 차이"></a>5-4. 정적 메소드와 프로토타입 메소드의 차이</h3><ol>
<li>정적 메소드와 프로토타입 메소드는 자신이 속해 있는 프로토타입 체인이 다르다.</li>
<li>정적메소드는 클래스로 호출하고 프로토타입 메소드는 인스턴스로 호출한다.</li>
<li>정적 메소드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메소드는 인스턴스 프로퍼티를 참조할 수 있다.</li>
</ol>
<h3 id="5-5-클래스에서-정희한-메소드의-특징"><a href="#5-5-클래스에서-정희한-메소드의-특징" class="headerlink" title="5-5. 클래스에서 정희한 메소드의 특징"></a>5-5. 클래스에서 정희한 메소드의 특징</h3><ol>
<li>function 키워드를 생략한 메소드 축약 표현을 사용한다.</li>
<li>객체 리터럴과는 다르게 클래스에 매소드를 정희할 때는 콤마가 필요 없다.</li>
<li>암묵적으로 strict 모드로 실행된다.</li>
<li>for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다.</li>
<li>내부 메소드[[Construct]]를 각지 않는 non-constructor이다. 따라서 new 연산자와 함께 호출할 수 없다.</li>
</ol>
<hr>
<h2 id="6-클래스의-인스턴스-생성-과정"><a href="#6-클래스의-인스턴스-생성-과정" class="headerlink" title="6. 클래스의 인스턴스 생성 과정"></a>6. 클래스의 인스턴스 생성 과정</h2><ol>
<li>인스턴스 생성과 this 바인딩</li>
</ol>
<p>new 연산자와 함께 클래스를 호출하면 constructor의 내부 코드가 실행된다. 암묵적으로 빈 객체가 생성되고 this에 바인딩된다. 따라서 constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킨다.</p>
<ol start="2">
<li>인스턴스 초기화</li>
</ol>
<p>this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티 값을 초기화한다.</p>
<ol start="3">
<li>프로토타입/ 정적 메소드 추가</li>
</ol>
<p>클래스 몸체에 프로토타입 메소드가 존재하면 클래스의 prototype 프로퍼티가 가리키는 객체에 메소드로 추가된다. 클래스 몸체에 정적 메소드가 존재하면 클래스에 메소드로 추가된다.</p>
<ol start="4">
<li>인스턴스 반환</li>
</ol>
<p>클래스의 모든 처리가 끝나면 완성된 인스턴스가 바잉딘된 this가 암묵적으로 반환된다.</p>
<hr>
<h2 id="7-프로퍼티"><a href="#7-프로퍼티" class="headerlink" title="7. 프로퍼티"></a>7. 프로퍼티</h2><h3 id="7-1-인스턴스-프로퍼티"><a href="#7-1-인스턴스-프로퍼티" class="headerlink" title="7-1. 인스턴스 프로퍼티"></a>7-1. 인스턴스 프로퍼티</h3><p>인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다.</p>
<h3 id="7-2-접근자-프로퍼티"><a href="#7-2-접근자-프로퍼티" class="headerlink" title="7-2. 접근자 프로퍼티"></a>7-2. 접근자 프로퍼티</h3><p>접근자 프로퍼티는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티다.<br>접근자 프로퍼티는 클래스에서도 사용할 수 있다.</p>
<h3 id="7-3-클래스-필드-정의-제안"><a href="#7-3-클래스-필드-정의-제안" class="headerlink" title="7-3. 클래스 필드 정의 제안"></a>7-3. 클래스 필드 정의 제안</h3><p>클래스 필드는 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어이다.<br>함수는 일급 객체이므로 함수를 클래스 필드에 할당할 수 있다. 따라서 클래스 필드를 통해 메소드를 정의할 수도 있다.</p>
<h3 id="7-4-private-필드-정의-제안"><a href="#7-4-private-필드-정의-제안" class="headerlink" title="7-4. private 필드 정의 제안"></a>7-4. private 필드 정의 제안</h3><p>constructor 내부에서 this를 통해 정의한 인스턴스 프로퍼티는 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있다.<br>private 필드의 선두에는 #을 붙여준다. private 필드를 참조할 때도 #을 붙어주어야 한다.</p>
<h3 id="7-5-static-필드-정의-제안"><a href="#7-5-static-필드-정의-제안" class="headerlink" title="7-5. static 필드 정의 제안"></a>7-5. static 필드 정의 제안</h3><p>클래스에는 static 메소드를 정의할 수 있다. 하지만 static 필드를 정의할 수는 없었다. 하지만 static public 필드, static private 필드, static private 메소드를 정의 할 수 있는 새로운 표준 사양인 static class features이 2019년 11월 현재, TC39 프로세스의 stage3에 제안되어 있다. 이 제안 중에 static public/private 필드는<br>2019년 11월 현재, 최신 브라우저(Chrome 72 이상)과 최신 Node.js(버전 12 이상)에 이미 구현되어 있다.</p>
<hr>
<h2 id="8-상속에-의한-클래스-확장"><a href="#8-상속에-의한-클래스-확장" class="headerlink" title="8. 상속에 의한 클래스 확장"></a>8. 상속에 의한 클래스 확장</h2><h3 id="8-1-클래스-상속과-생성자-함수-상속"><a href="#8-1-클래스-상속과-생성자-함수-상속" class="headerlink" title="8-1. 클래스 상속과 생성자 함수 상속"></a>8-1. 클래스 상속과 생성자 함수 상속</h3><p>상속에 의한 클래스 확장은 기존의 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것이다.<br>클래스와 생성자 함수는 인스턴스를 생성할 수 있는 함수하는 점에서 매우 유사하다. 하지만 클래스는 상속을 통해 기존의 클래스를 확장할 수 있는 문법이 기본적으로 제공되지만 생성자 함수는 그렇지 않다.</p>
<h3 id="8-2-extends-키워드"><a href="#8-2-extends-키워드" class="headerlink" title="8-2. extends 키워드"></a>8-2. extends 키워드</h3><p>상속을 통해 클래스를 확장하려면 extends 키워드를 사용하여 상속받을 클래스를 정희한다.<br>상속을 통해 확장된 서브 클래스(sub class)라 부르고, 서브 클래스에게 상속된 클래스를 수퍼 클래스(super class)라 부른다. 서브 클래스를 파생 클래스(derived class) 또는 자식 클래스(child class), 수퍼 클래스를 베이스 클래스(base class) 또는 부모 클래스(parent class)라고 부르기도 한다.</p>
<h3 id="8-3-동적-상속"><a href="#8-3-동적-상속" class="headerlink" title="8-3. 동적 상속"></a>8-3. 동적 상속</h3><p>extends 키워드는 생성자 함수를 상속받아 클래스를 확장할 수도 있다. 단, extends 키워드 앞에는 반드시 클래스가 와야 한다.</p>
<h3 id="8-4-서브-클래스의-constructor"><a href="#8-4-서브-클래스의-constructor" class="headerlink" title="8-4. 서브 클래스의 constructor"></a>8-4. 서브 클래스의 constructor</h3><p>클래스에 constructor를 생략하면 클래스에 아래와 같이 디폴트 constructor가 암묵적으로 정의된다.</p>
<h3 id="8-5-super-키워드"><a href="#8-5-super-키워드" class="headerlink" title="8-5. super 키워드"></a>8-5. super 키워드</h3><p>super키워드는 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드이다.</p>
<ul>
<li>super를 호출하면 수퍼 클래스의 constructor를 호출한다.</li>
<li>super를 참조하면 수퍼 클래스의 메소드를 호출할 수 있다.</li>
</ul>
<ol>
<li>서브 클래스에서 constructor를 생략하지 않는 경우, 서브 클래스의 constructor에서는 반드시 super를 호출해야 한다.</li>
<li>서브 클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.</li>
<li>super는 반드시 서브 클래스의 constructor에서만 호출한다. 서브 클래스가 아닌 클래스 또는 함수에서 호출하면 에러를 발생시킨다.</li>
</ol>
<p>메소드 내에서 super를 참조하면 수퍼 클래스의 메소드를 호출할 수 있다.</p>
<ol>
<li><p>서브 클래스의 프로토타입 메소드 내에서 super.prop는 수퍼 클래스의 프로토타입 메소드 prop를 가리킨다.</p>
</li>
<li><p>서브 클래스의 정적 메소드 내에서 super.prop는 수퍼 클래스의 정적 메소드 prop를 가리킨다.</p>
</li>
</ol>
<h3 id="8-6-상속-클래스의-인스턴스-생성-과정"><a href="#8-6-상속-클래스의-인스턴스-생성-과정" class="headerlink" title="8-6. 상속 클래스의 인스턴스 생성 과정"></a>8-6. 상속 클래스의 인스턴스 생성 과정</h3><ol>
<li>서브 클래스의 super 호출</li>
<li>수퍼 클래스의 인스턴스 생성과 this 바인딩</li>
<li>수퍼 클래스의 인스턴스 초기화</li>
<li>수퍼 클래스의 프로토타입 / 정적 메소드 추가</li>
<li>서브 클래스 constructor로의 복귀와 this 바인딩</li>
<li>서브 클래스의 인스턴스 초기화</li>
<li>인스턴스 반환</li>
</ol>
<h3 id="8-7-네이티브-생성자-함수-확장"><a href="#8-7-네이티브-생성자-함수-확장" class="headerlink" title="8-7. 네이티브 생성자 함수 확장"></a>8-7. 네이티브 생성자 함수 확장</h3><p>String, Number, Array와 같은 네이티브 생성자 함수도 [[Construct]] 내부 메소드를 갖는 함수이므로 extends 키워드를 사용하여 상속받을 수 있다.Array 생성자 함수를 상속받아 확장한 MyArray 클래스가 생성한 인스턴스는 Array.prototype와 MyArray.prototype의 모든 메소드를 사용할 수 있다.</p>
<p>이때 주의할 것은 Array.prototype의 메소드 중에서 map, filter와 같이 새로운 배열을 반환하는 메소드가 MyArray 클래스의 인스턴스를 반환한다는 것이다.</p>
<p>만약 새로운 배열을 반환하는 메소드가 MyArray 클래스의 인스턴스를 반환하지 않고 Array의 인스턴스를 반환하면 MyArray 클래스의 메소드와 메소드 체이닝(method chaining)이 불가능하다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/03/%ED%81%B4%EB%A1%9C%EC%A0%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/%ED%81%B4%EB%A1%9C%EC%A0%80/" class="post-title-link" itemprop="url">클로저</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-17 00:52:29 / Modified: 01:17:10" itemprop="dateCreated datePublished" datetime="2020-03-17T00:52:29+09:00">2020-03-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-렉시컬-스코프"><a href="#1-렉시컬-스코프" class="headerlink" title="1. 렉시컬 스코프"></a>1. 렉시컬 스코프</h2><p>자바스크립트는 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프(정적 스코프)라 한다.<br>렉시컬 환경의  “외부 렉시컬 환경에 대한 참조”에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 바로 렉시컬 스코프이다.</p>
<hr>
<h2 id="2-함수-객체의-내부-슬롯-Environment"><a href="#2-함수-객체의-내부-슬롯-Environment" class="headerlink" title="2. 함수 객체의 내부 슬롯 [[Environment]]"></a>2. 함수 객체의 내부 슬롯 [[Environment]]</h2><p>함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.</p>
<p>함수 객체의 내부 슬롯 [[Environment]]에 저장한 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프이다. 또한 자신이 호출되었을 때 생성될 함수 렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장될 참조값이다. 함수 객체는 내부 슬롯 [[Environment]]에 저장한 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억한다.</p>
<hr>
<h2 id="3-클로저와-렉시컬-환경"><a href="#3-클로저와-렉시컬-환경" class="headerlink" title="3. 클로저와 렉시컬 환경"></a>3. 클로저와 렉시컬 환경</h2><p>클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수(Free variable)라고 부른다. 클로저(closure)란 “함수가 자유 변수에 대해 닫혀있다(closed)”라는 의미이다. 이를 좀 더 알기 쉽게 의역하자면 “자유 변수와 묶여있는 함수”라고 할 수 있다.</p>
<hr>
<h2 id="4-클로저의-활용"><a href="#4-클로저의-활용" class="headerlink" title="4. 클로저의 활용"></a>4. 클로저의 활용</h2><p>클로저는 상태를 안전하게 유지하기 위해 사용한다. 상태가 의도치 않게 변경되지 않도록 안전하게 은닉(Information hiding)한다. 그리고 이전 상태를 기억하다가 상태가 변경되면 최신 상태(state)를 유지한다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/03/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/" class="post-title-link" itemprop="url">실행 컨텍스트</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-16 21:20:41" itemprop="dateCreated datePublished" datetime="2020-03-16T21:20:41+09:00">2020-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-17 00:50:59" itemprop="dateModified" datetime="2020-03-17T00:50:59+09:00">2020-03-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-소스-코트의-타입"><a href="#1-소스-코트의-타입" class="headerlink" title="1.  소스 코트의 타입"></a>1.  소스 코트의 타입</h2><p>ECMAScript 사양은 소스 코드(ECMAScript code)를 4가지 타입으로 구분한다.</p>
<ul>
<li>전역 코드 : 전역에 존재하는 소스 코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다. 소스 코드를 평가하여 전역 실행 컨텍스트를 만든다.</li>
<li>함수 코드 : 함수 내부에 존재하는 소스 코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다. 소스 코드를 평가하여 함수 실행 컨텍스트를 만든다.</li>
<li>eval 코드 : 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스 코드를 말한다. 소스 코드를 평가하여 eval 실행 컨텍스트를 만든다.</li>
<li>모듈 코드 : 모듈 내부에 존재하는 소스 코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다. 소스 코드를 평가하여 모듈 실행 컨텍스트를 만든다.</li>
</ul>
<hr>
<h2 id="2-소스-코드의-평가와-실행"><a href="#2-소스-코드의-평가와-실행" class="headerlink" title="2. 소스 코드의 평가와 실행"></a>2. 소스 코드의 평가와 실행</h2><p>소스 코드의 평가와 소스 코드의 실행으로 나누어 처리한다. 소스 코드 평가 과정에서는 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문 만을 먼저 실행하여 생성된 변수나 함수를 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록한다. 소스 코드의 평가 과정이 끝나면 비로소 선언문을 제외한 소스 코드가 순차적으로 실행되기 시작한다. 이때 소스 코드 실행에 필요한 정보, 즉 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 취득한다. 그리고 변수 값의 변경과 같은 소스 코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.</p>
<hr>
<h2 id="3-실행-컨텍스트의-역할"><a href="#3-실행-컨텍스트의-역할" class="headerlink" title="3. 실행 컨텍스트의 역할"></a>3. 실행 컨텍스트의 역할</h2><h3 id="1-전역-코드-평가"><a href="#1-전역-코드-평가" class="headerlink" title="1. 전역 코드 평가"></a>1. 전역 코드 평가</h3><p>먼저 전역 코드를 실행하기에 앞서 전역 코드 평가 과정을 거치며 전역 코드 실행을 위한 준비를 한다. 소스 코드 평가 과정에서는 선언문 만을 먼저 실행한다. 따라서 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행되고 그 결과 생성된 전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록된다. 또한 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 전역 객체의 프로퍼티와 메소드가 된다.</p>
<h3 id="2-전역-코드-실행"><a href="#2-전역-코드-실행" class="headerlink" title="2. 전역 코드 실행"></a>2. 전역 코드 실행</h3><p>전역 코드의 평가가 끝나면 전역 코드가 순차적으로 실행되기 시작한다. 이때 전역 변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.</p>
<h3 id="3-함수-코드-평가"><a href="#3-함수-코드-평가" class="headerlink" title="3. 함수 코드 평가"></a>3. 함수 코드 평가</h3><p>코드 실행 순서가 변경되어 함수 내부로 진입하면 함수 내부의 문들을 실행하기에 앞서 함수 코드 평가 과정을 거치며 함수 코드 실행을 위한 준비를 한다. 이때 매개 변수와 지역 변수 선언문이 먼저 실행되고 그 결과 생성된 매개 변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록된다. 또한 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체도 생성되어 지역 스코프에 등록된다.</p>
<h3 id="4-함수-코드-실행"><a href="#4-함수-코드-실행" class="headerlink" title="4. 함수 코드 실행"></a>4. 함수 코드 실행</h3><p>함수 코드의 평가가 끝나면 함수 코드가 순차적으로 실행되기 시작한다. 이때 매개 변수와 지역 변수에 값이 할당되고 console.log 메소드가 호출된다.</p>
<p>코드가 실행되려면 아래와 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.</p>
<ul>
<li>선언에 의해 생성된 모든 식별자를 스코프를 구분하여 등록하고 상태 변화를 지속적으로 관리 한다.</li>
<li>스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.</li>
<li>현재 실행 중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.</li>
</ul>
<p>실행 컨텍스트는 소스 코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.<br>즉, 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.</p>
<p>식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다.</p>
<hr>
<h2 id="4-실행-컨텍스트-스택"><a href="#4-실행-컨텍스트-스택" class="headerlink" title="4. 실행 컨텍스트 스택"></a>4. 실행 컨텍스트 스택</h2><p> 자바스크립트 엔진은 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성한다. 그리고 함수가 호출되면 함수 코드를 평가하여 함수 실행 컨텍스트를 생성한다.<br>이때 생성된 실행 컨텍스트는 스택 자료 구조로 관리된다. 이를 실행 컨텍스트 스택(Execution context stack)이라고 부른다.</p>
<p>실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행 중인 코드의 실행 컨텍스트이다. 따라서 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트를 실행 중인 실행 컨텍스트(running execution context)라 부른다.</p>
<hr>
<h2 id="5-동기식-처리-모델과-비동기식-처리-모델"><a href="#5-동기식-처리-모델과-비동기식-처리-모델" class="headerlink" title="5. 동기식 처리 모델과 비동기식 처리 모델"></a>5. 동기식 처리 모델과 비동기식 처리 모델</h2><p>하나의 처리가 종료되어야 다음 처리를 실행할 수 있는 것을 동기식 처리 모델(Synchronous processing model)이라고 한다.</p>
<p>자바스크립트는 비동기식 처리 모델을 지원한다. 비동기식 처리 모델(Asynchronous processing model 또는 Non-Blocking processing model)은 병렬적으로 태스크를 수행한다. 즉, 태스크가 종료되지 않은 상태라 하더라도 대기하지 않고 다음 태스크를 실행한다.</p>
<hr>
<h2 id="6-렉시컬-환경"><a href="#6-렉시컬-환경" class="headerlink" title="6. 렉시컬 환경"></a>6. 렉시컬 환경</h2><p>렉시컬 환경(Lexical Environment)은 식별자와 식별자에 바인딩된 값 그리고 상위 스코프에 대한 참조를 기록하는 환경으로 실행 컨텍스트를 구성하는 컴포넌트이다. 실행 컨텍스트 스택이 코드의 실행 순서를 관리한다면 렉시컬 환경은 스코프와 식별자를 관리한다.</p>
<hr>
<h2 id="7-실행-컨텍스트의-생성과-식별자-검색-과정"><a href="#7-실행-컨텍스트의-생성과-식별자-검색-과정" class="headerlink" title="7. 실행 컨텍스트의 생성과 식별자 검색 과정"></a>7. 실행 컨텍스트의 생성과 식별자 검색 과정</h2><h3 id="7-1-전역-객체-생성"><a href="#7-1-전역-객체-생성" class="headerlink" title="7-1. 전역 객체 생성"></a>7-1. 전역 객체 생성</h3><p>전역 객체는 전역 코드가 평가되기 이전에 생성된다. 이때 전역 객체에는 전역 프로퍼티와 전역 함수, 표준 빌트인 객체가 추가되며 동작 환경(클라이언트 사이드 또는 서버 사이드)에 따라 클라이언트 사이드 Web API 또는 특정 환경을 위한 호스트 객체를 포함한다.<br>전역 객체도 Object.prototype을 상속받는다. 즉, 전역 객체도 프로토타입 체인의 일원이다.</p>
<hr>
<h3 id="7-2-전역-코드-평가"><a href="#7-2-전역-코드-평가" class="headerlink" title="7-2. 전역 코드 평가"></a>7-2. 전역 코드 평가</h3><ol>
<li>전역 실행 컨텍스트 생성</li>
</ol>
<p>먼저 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시한다. 이때 전역 실행 컨텍스트는 실행 컨텍스트 스택의 최상위, 즉 실행 중인 실행 컨텍스트(running execution context)가 된다.</p>
<ol start="2">
<li>전역 레시컬 환경 생성</li>
</ol>
<p>전역 렉시컬 환경(Global Lexical Environment)을 생성하고 전역 실행 컨텍스트의 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트에 바인딩한다.</p>
<hr>
<h3 id="7-3-전역-코드-실행"><a href="#7-3-전역-코드-실행" class="headerlink" title="7-3. 전역 코드 실행"></a>7-3. 전역 코드 실행</h3><p>식별자가 선언된 식별자인지, 선언된 식별자라면 어느 스코프의 식별자를 참조하면 되는지 결정할 필요가 있다. 이를 식별자 결정(identifier resolution)이라 한다.<br>식별자 결정을 위해 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작한다. 선언된 식별자는 실행 컨텍스트의 렉시컬 환경의 환경 레코드에 등록되어 있다.</p>
<hr>
<h3 id="7-4-foo-함수-코드-평가"><a href="#7-4-foo-함수-코드-평가" class="headerlink" title="7-4. foo 함수 코드 평가"></a>7-4. foo 함수 코드 평가</h3><ul>
<li>함수 실행 컨텍스트 생성</li>
<li>함수 렉시컬 환경 생성<ul>
<li>함수 환경 레코드 생성</li>
<li>외부 렉시컬 환경에 대한 참조 할당</li>
<li>this 바인딩</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-5-foo-함수-코드-실행"><a href="#7-5-foo-함수-코드-실행" class="headerlink" title="7-5. foo 함수 코드 실행"></a>7-5. foo 함수 코드 실행</h3><p>식별자 결정을 위해 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색하기 시작한다. </p>
<hr>
<h3 id="7-6-bar-함수-코드-평가"><a href="#7-6-bar-함수-코드-평가" class="headerlink" title="7-6. bar 함수 코드 평가"></a>7-6. bar 함수 코드 평가</h3><p>bar 함수가 호출되면 함수 내부로 코드의 제어권이 이동한다. 그리고 함수 코드를 평가하기 시작한다. 실행 컨텍스트와 렉시컬 환경의 생성 과정은 foo 함수 코드 평가와 동일하다.</p>
<hr>
<h3 id="7-7-bar-함수-코드-실행"><a href="#7-7-bar-함수-코드-실행" class="headerlink" title="7-7. bar 함수 코드 실행"></a>7-7. bar 함수 코드 실행</h3><ol>
<li>식별자 console 검색</li>
<li>log 메소드 검색</li>
<li>표현식 a + b + x + y + z의 평가</li>
<li>console.log 메소드 호출</li>
</ol>
<hr>
<h3 id="7-8-bar-함수-코드-실행-종료"><a href="#7-8-bar-함수-코드-실행-종료" class="headerlink" title="7-8. bar 함수 코드 실행 종료"></a>7-8. bar 함수 코드 실행 종료</h3><p>console.log 메소드가 호출되고 종료하면 더 이상 실행할 코드가 없으므로 bar 함수 코드의 실행이 종료된다. 이때 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 팝되어 제거되고 foo 실행 컨텍스트가 실행 중인 실행 컨텍스트가 된다.</p>
<hr>
<h3 id="7-9-foo-함수-코드-실행-종료"><a href="#7-9-foo-함수-코드-실행-종료" class="headerlink" title="7-9. foo 함수 코드 실행 종료"></a>7-9. foo 함수 코드 실행 종료</h3><p>bar 함수가 종료하면 더 이상 실행할 코드가 없으므로 foo 함수 코드의 실행이 종료된다. 이때 실행 컨텍스트 스택에서 foo 함수 실행 컨텍스트가 팝되어 제거되고 전역 실행 컨텍스트가 실행 중인 실행 컨텍스트가 된다.</p>
<hr>
<h3 id="7-10-전역-코드-실행-종료"><a href="#7-10-전역-코드-실행-종료" class="headerlink" title="7-10. 전역 코드 실행 종료"></a>7-10. 전역 코드 실행 종료</h3><p>foo 함수가 종료하면 더 이상 실행할 전역 코드가 없으므로 전역 코드의 실행이 종료되고 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 팝되어 실행 컨텍스트 스택에는 아무것도 남아있지 않게 된다.</p>
<hr>
<h2 id="8-실행-컨텍스트와-블록-레벨-스코프"><a href="#8-실행-컨텍스트와-블록-레벨-스코프" class="headerlink" title="8. 실행 컨텍스트와 블록 레벨 스코프"></a>8. 실행 컨텍스트와 블록 레벨 스코프</h2><p>let 키워드로 선언한 변수는 모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 을 지역 스코프로 인정하는 블록 레벨 스코프(Block-level scope)를 따른다.</p>
<p>if 문의 코드 블록 내에서 let 키워드로 변수가 선언되었다. 따라서 if 문이 실행되면 if 문의 블록 레벨 스코프를 생성해야 한다. 이를 위해 if 문을 위한 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다. 이때 새롭게 생성된 if 문을 위한 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 교체된 이전의 전역 렉시컬 환경을 가리킨다.<br>if 문 실행이 종료되면 if 문이 실행되기 이전의 렉시컬 환경으로 되돌린다.이는 if 문 뿐만이 아니라 모든 블록문에 적용된다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/03/this%ED%82%A4%EC%9B%8C%EB%93%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/this%ED%82%A4%EC%9B%8C%EB%93%9C/" class="post-title-link" itemprop="url">this</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-16 20:45:05 / Modified: 21:20:49" itemprop="dateCreated datePublished" datetime="2020-03-16T20:45:05+09:00">2020-03-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-this-키워드"><a href="#1-this-키워드" class="headerlink" title="1. this 키워드"></a>1. this 키워드</h2><p>this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메소드를 참조할 수 있다. this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.</p>
<hr>
<h2 id="2-함수-호출-방식과-this-바인딩"><a href="#2-함수-호출-방식과-this-바인딩" class="headerlink" title="2. 함수 호출 방식과 this 바인딩"></a>2. 함수 호출 방식과 this 바인딩</h2><p>this가 가리키는 값, 즉 this 바인딩은 함수의 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.</p>
<hr>
<h3 id="2-1-일반-함수-호출"><a href="#2-1-일반-함수-호출" class="headerlink" title="2-1. 일반 함수 호출"></a>2-1. 일반 함수 호출</h3><p>기본적으로 this에는 전역 객체(Global object)가 바인딩된다. 즉, 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.</p>
<hr>
<h3 id="2-2-메소드-호출"><a href="#2-2-메소드-호출" class="headerlink" title="2-2. 메소드 호출"></a>2-2. 메소드 호출</h3><p>메소드 내부의 this는 메소드를 호출한 객체, 즉 메소드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체에 바인딩된다.</p>
<hr>
<h3 id="2-3-생성자-함수-호출"><a href="#2-3-생성자-함수-호출" class="headerlink" title="2-3. 생성자 함수 호출"></a>2-3. 생성자 함수 호출</h3><p>생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.</p>
<hr>
<h3 id="2-4-Function-prototype-apply-call-bind-메소드에-의한-간접-호출"><a href="#2-4-Function-prototype-apply-call-bind-메소드에-의한-간접-호출" class="headerlink" title="2-4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출"></a>2-4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출</h3><p>apply와 call 메소드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메소드는 함수를 호출하면서 첫번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다. Function.prototype.bind 메소드는 apply와 call 메소드와는 달리 함수를 호출하지 않고 this로 사용할 객체만을 전달한다. bind 메소드는 메소드의 this와 메소드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/03/%EB%B9%8C%ED%8A%B8%EC%9D%B8%EA%B0%9D%EC%B2%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/%EB%B9%8C%ED%8A%B8%EC%9D%B8%EA%B0%9D%EC%B2%B4/" class="post-title-link" itemprop="url">빌트인 객체</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-15 21:31:24 / Modified: 22:43:37" itemprop="dateCreated datePublished" datetime="2020-03-15T21:31:24+09:00">2020-03-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-자바스크립트-객체의-분류"><a href="#1-자바스크립트-객체의-분류" class="headerlink" title="1. 자바스크립트 객체의 분류"></a>1. 자바스크립트 객체의 분류</h2><ul>
<li><p>표준 빌트인 객체</p>
<ul>
<li>표준 빌트인 객체는 ECMAScript 사양에 정의된 객체를 말하며 애플리케이션 전역의 공통 기능을 제공한다. 표준 빌트인 객체는 ECMAScript 사양에 정의된 객체이므로 자바스크립트 실행 환경(브라우저 또는 Node.js 환경)과 관계없이 언제나 사용할 수 있다. 표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공된다. 따라서 별도의 선언없이 전역 변수처럼 언제나 참조할 수 있다.</li>
</ul>
</li>
<li><p>호스트 객체</p>
<ul>
<li>호스트 객체는 ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경(브라우저 환경 또는 Node.js 환경. “3.1 자바스크립트 실행 환경” 참고)에서 추가적으로 제공하는 객체를 말한다.<br>브라우저 환경에서는 DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker와 같은 클라이언트 사이드 Web API를 호스트 객체로 제공하고 Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공한다.</li>
</ul>
</li>
<li><p>사용자 정의 객체</p>
<ul>
<li>사용자 정의 객체는 표준 빌트인 객체와 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체를 말한다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-표준-빌트인-객체"><a href="#2-표준-빌트인-객체" class="headerlink" title="2. 표준 빌트인 객체"></a>2. 표준 빌트인 객체</h2><p>Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체이다. 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메소드와 정적 메소드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메소드만을 제공한다.</p>
<hr>
<h2 id="3-원시값과-래퍼-객체"><a href="#3-원시값과-래퍼-객체" class="headerlink" title="3. 원시값과 래퍼 객체"></a>3. 원시값과 래퍼 객체</h2><p>원시값인 문자열, 숫자, 불리언 값의 경우, 마치 객체처럼 이들 원시값에 대해 마침표 표기법(또는 대괄호 표기법)으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해 주기 때문이다. 즉, 원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하고 생성된 객체로 프로퍼티에 접근하거나 메소드를 호출하고 다시 원시값으로 되돌린다.<br>이처럼 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 레퍼 객체(wrapper object)라 한다.</p>
<hr>
<h2 id="4-전역-객체"><a href="#4-전역-객체" class="headerlink" title="4. 전역 객체"></a>4. 전역 객체</h2><p>전역 객체(Global Object)는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다.<br>전역 객체는 자바스크립트 환경에 따라 지칭하는 이름이 제각각이다. 브라우저 환경에서는 window가 전역 객체를 가리키지만 Node.js 환경에서는 global이 전역 객체를 가리킨다.</p>
<ul>
<li>전역 객체의 특징<ul>
<li>전역 객체는 개발자가 의도적으로 생성할 수 없다. 즉, 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.</li>
<li>전역 객체의 프로퍼티를 참조할 때 window(또는 global)를 생략할 수 있다.</li>
<li>전역 객체는 Object, String, Number, Boolean, Function, Array, RegExp, Date, Math, Promise와 같은 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.</li>
<li>자바스크립트 실행 환경에 따라 추가적으로 프로퍼티와 메소드를 갖는다. 브라우저 환경에서는 DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker와 같은 클라이언트 사이드 Web API를 호스트 객체로 제공하고 Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공한다.</li>
<li>var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.</li>
<li>let이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.</li>
<li>브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-1-빌트인-전역-프로퍼티"><a href="#4-1-빌트인-전역-프로퍼티" class="headerlink" title="4-1. 빌트인 전역 프로퍼티"></a>4-1. 빌트인 전역 프로퍼티</h3><p>빌트인 전역 프로퍼티는 전역 객체의 프로퍼티를 의미한다. 주로 애플리케이션 전역에서 사용하는 값을 제공한한다.  </p>
<hr>
<h4 id="4-1-1-Infinity"><a href="#4-1-1-Infinity" class="headerlink" title="4-1-1. Infinity"></a>4-1-1. Infinity</h4><p>Infinity 프로퍼티는 양/음의 무한대를 나타내는 숫자값 Infinity를 갖는다.</p>
<hr>
<h4 id="4-1-2-NaN"><a href="#4-1-2-NaN" class="headerlink" title="4-1-2. NaN"></a>4-1-2. NaN</h4><p>NaN 프로퍼티는 숫자가 아님을 나타내는 숫자값 NaN을 갖는다. NaN 프로퍼티는 Number.NaN 프로퍼티와 같다.</p>
<hr>
<h4 id="4-1-3-undefined"><a href="#4-1-3-undefined" class="headerlink" title="4-1-3. undefined"></a>4-1-3. undefined</h4><p>undefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다.</p>
<hr>
<h3 id="4-2-빌트인-전역-함수"><a href="#4-2-빌트인-전역-함수" class="headerlink" title="4-2. 빌트인 전역 함수"></a>4-2. 빌트인 전역 함수</h3><p>빌트인 전역 함수는 애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메소드이다.</p>
<hr>
<h4 id="4-2-1-eval"><a href="#4-2-1-eval" class="headerlink" title="4-2-1. eval"></a>4-2-1. eval</h4><p>문자열 형태로 매개변수에 전달된 코드를 런타임에 동적으로 평가하고 실행하여 결과값을 반환한다. 전달된 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행 후 마지막 결과값을 반환한다.</p>
<hr>
<h4 id="4-2-2-isFinite"><a href="#4-2-2-isFinite" class="headerlink" title="4-2-2. isFinite"></a>4-2-2. isFinite</h4><p>매개 변수에 전달된 값이 정상적인 유한수인지 검사하여 그 결과를 불리언 타입으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다.</p>
<hr>
<h4 id="4-2-3-isNaN"><a href="#4-2-3-isNaN" class="headerlink" title="4-2-3. isNaN"></a>4-2-3. isNaN</h4><p>매개변수에 전달된 값이 NaN인지 검사하여 그 결과를 불리런 타입으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다.</p>
<hr>
<h4 id="4-2-4-parseFloat"><a href="#4-2-4-parseFloat" class="headerlink" title="4-2-4. parseFloat"></a>4-2-4. parseFloat</h4><p>매개변수에 전달된 문자열을 부동소수점 숫자로 변환하여 반환한다.</p>
<hr>
<h4 id="4-2-5-parseInt"><a href="#4-2-5-parseInt" class="headerlink" title="4-2-5. parseInt"></a>4-2-5. parseInt</h4><p>매개변수에 전달된 문자열을 정수형 숫자(Integer)로 해석(parsing)하여 반환한다. 반환값은 언제나 10진수이다.</p>
<hr>
<h4 id="4-2-6-encodeURI-decodeURI"><a href="#4-2-6-encodeURI-decodeURI" class="headerlink" title="4-2-6. encodeURI / decodeURI"></a>4-2-6. encodeURI / decodeURI</h4><p>encodeURI 함수는 매개변수로 전달된 URI를 인코딩한다. URI는 인터넷에 있는 자원을 나타내는 유일한 주소를 말한다. URI의 하위개념으로 URL, URN이 있다. 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다.</p>
<hr>
<h4 id="4-2-7-encodeURIComponent-decodeURIComponent"><a href="#4-2-7-encodeURIComponent-decodeURIComponent" class="headerlink" title="4-2-7. encodeURIComponent / decodeURIComponent"></a>4-2-7. encodeURIComponent / decodeURIComponent</h4><p>encodeURIComponent 함수는 매개변수로 전달된 URI(Uniform Resource Identifier) 구성 요소(component)를 인코딩한다. 여기서 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다. 단, 알파벳, 0~9의 숫자, - _ . ! ~ * ‘ ( ) 문자는 이스케이프 처리에서 제외된다. decodeURIComponent 함수는 매개변수로 전달된 URI 구성 요소를 디코딩한다.</p>
<hr>
<h3 id="4-3-암묵적-전역"><a href="#4-3-암묵적-전역" class="headerlink" title="4-3. 암묵적 전역"></a>4-3. 암묵적 전역</h3><p>foo 함수가 호출되면 자바스크립트 엔진은 변수 y에 값을 할당하기 위해 먼저 스코프 체인을 통해 선언된 변수인지 확인한다. 이때 foo 함수의 스코프와 전역 스코프 어디에서도 변수 y의 선언을 찾을 수 없으므로 참조 에러가 발생해야 한다. 하지만 자바스크립트 엔진은 y = 20을 window.y = 20으로 해석하여 전역 객체에 프로퍼티를 동적 생성한다. 결국 y는 전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작한다. 이러한 현상을 암묵적 전역이라 한다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/03/%EC%97%84%EA%B2%A9%EB%AA%A8%EB%93%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/%EC%97%84%EA%B2%A9%EB%AA%A8%EB%93%9C/" class="post-title-link" itemprop="url">Strict mode</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-15 21:09:56 / Modified: 21:26:11" itemprop="dateCreated datePublished" datetime="2020-03-15T21:09:56+09:00">2020-03-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Strict-mode란"><a href="#1-Strict-mode란" class="headerlink" title="1. Strict mode란?"></a>1. Strict mode란?</h2><p>잠재적인 오류를 발생시키기 어려운 개발 환경을 만들고 그 환경에서 개발을 하는 것이 보다 근본적인 해결책이므로 이를 지원하기 위해 ES5부터 stict mode가 추가되었다. strict mode는 자바스크립트 언어의 문법을 보다 엄격히 적용하여 기존에는 무시되던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.</p>
<hr>
<h2 id="2-Strict-mode의-적용"><a href="#2-Strict-mode의-적용" class="headerlink" title="2. Strict mode의 적용"></a>2. Strict mode의 적용</h2><p>Strict mode를 적용하려면 전역의 선두 또는 함수 몸체의 선두에 ‘use strict’;를 추가한다. 전역의 선두에 추가하면 스크립트 전체에 strict mode가 적용된다.</p>
<hr>
<h2 id="3-전역에-Strict-mode를-적용하는-것은-피하자"><a href="#3-전역에-Strict-mode를-적용하는-것은-피하자" class="headerlink" title="3. 전역에 Strict mode를 적용하는 것은 피하자."></a>3. 전역에 Strict mode를 적용하는 것은 피하자.</h2><p>strict mode 스크립트와 non-strict mode 스크립트를 혼용하는 것은 오류를 발생시킬 수 있다. 특히 외부 서드 파티 라이브러리를 사용하는 경우, 라이브러리가 non-strict mode일 경우도 있기 때문에 전역에 strict mode를 적용하는 것은 바람직하지 않다. 이러한 경우, 즉시 실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다.</p>
<hr>
<h2 id="4-함수-단위로-Strict-mode를-적용하는-것도-피하자"><a href="#4-함수-단위로-Strict-mode를-적용하는-것도-피하자" class="headerlink" title="4. 함수 단위로 Strict mode를 적용하는 것도 피하자."></a>4. 함수 단위로 Strict mode를 적용하는 것도 피하자.</h2><p>함수 단위로 strict mode를 적용할 수도 있다. 그러나 어떤 함수는 strict mode를 적용하고 어떤 함수는 strict mode를 적용하지 않는 것은 바람직하지 않으며 모든 함수에 일일이 strict mode를 적용하는 것은 번거로운 일이다. 그래서 strict mode는 즉시 실행 함수로 감싼 스크립트 단위로 적용하는 것이 바람직하다.</p>
<hr>
<h2 id="5-Strict-mode가-발생시키는-에러"><a href="#5-Strict-mode가-발생시키는-에러" class="headerlink" title="5. Strict mode가 발생시키는 에러"></a>5. Strict mode가 발생시키는 에러</h2><h3 id="5-1-암묵적-전역"><a href="#5-1-암묵적-전역" class="headerlink" title="5-1. 암묵적 전역"></a>5-1. 암묵적 전역</h3><p>선언하지 않은 변수를 참조하면 ReferenceError가 발생한다.</p>
<hr>
<h3 id="5-2-변수-함수-매개변수의-삭제"><a href="#5-2-변수-함수-매개변수의-삭제" class="headerlink" title="5-2. 변수, 함수, 매개변수의 삭제"></a>5-2. 변수, 함수, 매개변수의 삭제</h3><p>delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생한다.</p>
<hr>
<h3 id="5-3-매개변수-이름의-중복"><a href="#5-3-매개변수-이름의-중복" class="headerlink" title="5-3. 매개변수 이름의 중복"></a>5-3. 매개변수 이름의 중복</h3><p>중복된 함수 매개변수 이름을 사용하면 SyntaxError가 발생한다.</p>
<hr>
<h3 id="5-4-with-문의-사용"><a href="#5-4-with-문의-사용" class="headerlink" title="5-4. with 문의 사용"></a>5-4. with 문의 사용</h3><p>with 문을 사용하면 SyntaxError가 발생한다.</p>
<hr>
<h2 id="6-Strict-mode-적용에-의한-변화"><a href="#6-Strict-mode-적용에-의한-변화" class="headerlink" title="6. Strict mode 적용에 의한 변화"></a>6. Strict mode 적용에 의한 변화</h2><h3 id="6-1-일반-함수의-this"><a href="#6-1-일반-함수의-this" class="headerlink" title="6-1. 일반 함수의 this"></a>6-1. 일반 함수의 this</h3><p>strict mode 에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다.</p>
<hr>
<h3 id="6-2-arguments-객체"><a href="#6-2-arguments-객체" class="headerlink" title="6-2. arguments 객체"></a>6-2. arguments 객체</h3><p>strict mode 에서는 매개변수에 전달된 인수를 재할당하여 변경하여도 arguments 객체에 반영되지 않는다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/03/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/" class="post-title-link" itemprop="url">Prototype</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-09 22:06:37" itemprop="dateCreated datePublished" datetime="2020-03-09T22:06:37+09:00">2020-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-10 23:06:11" itemprop="dateModified" datetime="2020-03-10T23:06:11+09:00">2020-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-객체지향-프로그래밍"><a href="#1-객체지향-프로그래밍" class="headerlink" title="1. 객체지향 프로그래밍"></a>1. 객체지향 프로그래밍</h2><p>객체지향 프로그래밍은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체들의 집합으로 프로그럄을 표현하려는 프로그래밍 패러다임을 말한다.</p>
<hr>
<h2 id="2-상속과-프로토타입"><a href="#2-상속과-프로토타입" class="headerlink" title="2. 상속과 프로토타입"></a>2. 상속과 프로토타입</h2><p>상속은 객체지향 프로그래밍의 핵심 개념으로 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다. 자바스크립트는 프로토타입을 기반으로 상속을 구현한다.</p>
<hr>
<h2 id="3-프로토타입-객체"><a href="#3-프로토타입-객체" class="headerlink" title="3. 프로토타입 객체"></a>3. 프로토타입 객체</h2><p>프로토타입 객체란 객체 지향 프로그래밍의 근간을 이루는 객체간 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티를 제공한다. 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다. 모든 객체는 [[Prototype]] 이라는 내부 슬롯을 갖는다. 모든 객체는 하나의 프로토타입을 갖으며 프로토타입은 객체의 생성 방식에 의해 결정된다. 객체와 프로토타입과 생성자 함수는 서로 연결되어 있다. 객체는 <strong>proto</strong>접근자 프로퍼티를 통해 자신의 [[Prototype]] 내부 슬롯이 가리키는 객체에 접근할 수 있고, 프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있다. 생성자 함수는 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.</p>
<hr>
<h3 id="3-1-proto접근자-프로퍼티"><a href="#3-1-proto접근자-프로퍼티" class="headerlink" title="3-1.proto접근자 프로퍼티"></a>3-1.<strong>proto</strong>접근자 프로퍼티</h3><p>모든 객체는 <strong>proto</strong>접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[prototype]] 내부 슬롯에 접근할 수 있다. <strong>proto</strong>접근자 프로퍼티는 상속을 통해 사용된다.</p>
<hr>
<h3 id="3-2-함수-객체의-prototype-프로퍼티"><a href="#3-2-함수-객체의-prototype-프로퍼티" class="headerlink" title="3-2. 함수 객체의 prototype 프로퍼티"></a>3-2. 함수 객체의 prototype 프로퍼티</h3><p>함수 객체는 <strong>proto</strong>접근자 프로퍼티 이외에 prototype 프로퍼티도 소유한다. 함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. 모든 객체가 가지고 있는 <strong>proto</strong>접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다. 하지만 이들 프로퍼티를 사용하는 주체가 다르다.</p>
<hr>
<h3 id="3-3-프로타입의-constructor-프로퍼티와-생성자-함수"><a href="#3-3-프로타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="3-3. 프로타입의 constructor 프로퍼티와 생성자 함수"></a>3-3. 프로타입의 constructor 프로퍼티와 생성자 함수</h3><p>모든 프로토타입은 constructor 프로퍼티를 갖는다. constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. 이 연결은 함수 객체가 생성될 때 이루어 진다.</p>
<hr>
<h2 id="4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><a href="#4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입" class="headerlink" title="4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입"></a>4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</h2><ul>
<li>리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입<ul>
<li>객체 리터럴 | Object | Object.prototype</li>
<li>함수 리터럴 | Function | Function.prototype</li>
<li>배열 리터럴 | Array | Array.prototype</li>
<li>정규 표현식 리터럴 | RegExp | RegExp.prototype</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-프로토타입의-생성-시점"><a href="#5-프로토타입의-생성-시점" class="headerlink" title="5. 프로토타입의 생성 시점"></a>5. 프로토타입의 생성 시점</h2><p>프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.</p>
<hr>
<h3 id="5-1-사용자-정의-생성자-함수와-프로토타입-생성-시점"><a href="#5-1-사용자-정의-생성자-함수와-프로토타입-생성-시점" class="headerlink" title="5-1. 사용자 정의 생성자 함수와 프로토타입 생성 시점"></a>5-1. 사용자 정의 생성자 함수와 프로토타입 생성 시점</h3><p>생성자 함수로서 호출할 수 있는 함수, 즉 constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다. non-constructor는 프로토타입이 생성되지 않는다.</p>
<hr>
<h3 id="5-2-빌트인-생성자-함수와-프로토타입-생성-시점"><a href="#5-2-빌트인-생성자-함수와-프로토타입-생성-시점" class="headerlink" title="5-2. 빌트인 생성자 함수와 프로토타입 생성 시점"></a>5-2. 빌트인 생성자 함수와 프로토타입 생성 시점</h3><p>빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성된다. 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 이때 빌트인 생성자 함수와 더불어 프로토타입이 생성된다. 생성된 프로토타입은 빌트인 생성자 함수의 Prototype 프로퍼티에 바인딩된다.</p>
<hr>
<h2 id="6-객체-생성-방식과-프로토타입의-결정"><a href="#6-객체-생성-방식과-프로토타입의-결정" class="headerlink" title="6. 객체 생성 방식과 프로토타입의 결정"></a>6. 객체 생성 방식과 프로토타입의 결정</h2><ul>
<li>다양한 객체 생성 방법<ul>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create 메소드</li>
<li>클래스 (ES6)</li>
</ul>
</li>
</ul>
<p>프로토타입은 추상 연산 ObjectCreate에 전달되는 인수에 의해 결정된다. 이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.</p>
<hr>
<h3 id="6-1-객체-리터럴에-의해-생성된-객체의-프로토타입"><a href="#6-1-객체-리터럴에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-1. 객체 리터럴에 의해 생성된 객체의 프로토타입"></a>6-1. 객체 리터럴에 의해 생성된 객체의 프로토타입</h3><p>자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할 때, 추상 연산 ObjectCreate를 호출한다.</p>
<hr>
<h3 id="6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-2. Object 생성자 함수에 의해 생성된 객체의 프로토타입"></a>6-2. Object 생성자 함수에 의해 생성된 객체의 프로토타입</h3><p>명시적으로 Object 생성자 함수를 호출하여 객체를 생성하면 빈 객체가 생성된다. Object 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 추상 연산 ObjectCreate를 호출한다. 이때 Object 생성자 함수에 의해 생성되는 객체의 프로토타입은 Object.prototype이다. </p>
<hr>
<h3 id="6-3-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#6-3-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-3. 생성자 함수에 의해 생성된 객체의 프로토타입"></a>6-3. 생성자 함수에 의해 생성된 객체의 프로토타입</h3><p>new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다. 이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 즉, 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 빌트인 객체인 Object 생성자 함수와 더불어 생성된 프로토타입 Object.prototype은 다양한 빌트인 메소드(hasOwnProperty, propertyIsEnumerable 등)를 갖고 있다.</p>
<hr>
<h2 id="7-프로토타입-체인"><a href="#7-프로토타입-체인" class="headerlink" title="7. 프로토타입 체인"></a>7. 프로토타입 체인</h2><p>자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <strong>proto</strong>접근자 프로퍼티가 가리키는 링크를 따라 잔신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이것을 프로토타입 체인이라 한다. 프로토타입 체인은 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘이다.</p>
<hr>
<h2 id="8-캡슐화"><a href="#8-캡슐화" class="headerlink" title="8. 캡슐화"></a>8. 캡슐화</h2><p>캘슐화는 정보의 일부를 외부에 감추어 은닉하는 것을 말한다. 즉, 외부에 공개할 필요가 없는 구현의 일부를 외부에 노출되지 않도록 감추어 적절치 못한 접근으로부터 정보를 보호하고 객체간의 상호 의존성, 즉 결합도를 낮추는 효과가 얻는다.</p>
<hr>
<h2 id="9-오버라이딩과-프로퍼티-쉐도잉"><a href="#9-오버라이딩과-프로퍼티-쉐도잉" class="headerlink" title="9. 오버라이딩과 프로퍼티 쉐도잉"></a>9. 오버라이딩과 프로퍼티 쉐도잉</h2><p>오버라이딩은 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의하여 사용하는 방식이다. 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가한다. 이때 인스턴스 메소드 sayHello는 프로토타입 메소드 sayHello를 오버라이딩하였고 프로토타입 메소드 sayHello는 가려진다.</p>
<hr>
<h2 id="10-프로토타입의-교체"><a href="#10-프로토타입의-교체" class="headerlink" title="10. 프로토타입의 교체"></a>10. 프로토타입의 교체</h2><p>프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있다.</p>
<hr>
<h3 id="10-1-생성자-함수에-의한-프로토타입의-교체"><a href="#10-1-생성자-함수에-의한-프로토타입의-교체" class="headerlink" title="10-1. 생성자 함수에 의한 프로토타입의 교체"></a>10-1. 생성자 함수에 의한 프로토타입의 교체</h3><p>생성자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체한 객체 리터럴에는 constructor 프로퍼티가 없다. constructor 프로퍼티는 자바스크립트 엔진이 프로토타입을 생성할 때 암묵적으로 추가한 프로퍼티이다. 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다. 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티를 되살린다.</p>
<hr>
<h3 id="10-2-인스턴스에-의한-프로토타입의-교체"><a href="#10-2-인스턴스에-의한-프로토타입의-교체" class="headerlink" title="10-2. 인스턴스에 의한 프로토타입의 교체"></a>10-2. 인스턴스에 의한 프로토타입의 교체</h3><p>프로토타입은 생성자 함수의 prototype 프로퍼티 뿐만 아니라 인스턴스의 <strong>proto</strong>접근자 프로퍼티로 접근할 수 있고 프로토타입을 교체할 수 있다. 생성자 함수의 prototype 프로퍼티에 다른 임의의 객체를 바인딩하는 것은 미래에 생성할 인스턴스의 프로토타입을 교체할 수 있다. 생성자 함수에 의한 프로토타입 교체와 마찬가지로 인스턴스에 의한 포로토타입 교체도 constructor 프로퍼티와 생성자 함수 간의 연결을 파괴한다. 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하고 생성자 함수의 prototype 프로퍼티를 재설정하여 파괴된 생성자 함수와 프로토타입 간의 연결을 되살릴 수 있다.</p>
<hr>
<h2 id="11-instanceof연산자"><a href="#11-instanceof연산자" class="headerlink" title="11. instanceof연산자"></a>11. instanceof연산자</h2><p>instanceof연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자,우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 만약 우변의 피연산자가 함수가 아닌 경우, TypeError가 발생한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">객체 instancof 생성자 함수</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="12-직접-상속"><a href="#12-직접-상속" class="headerlink" title="12. 직접 상속"></a>12. 직접 상속</h2><h3 id="12-1-Object-create에-의한-직접-상속"><a href="#12-1-Object-create에-의한-직접-상속" class="headerlink" title="12-1. Object.create에 의한 직접 상속"></a>12-1. Object.create에 의한 직접 상속</h3><p>Object.create 메소드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. Object.create 메소드도 다른 객체 생성 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다. Object.create 메소드의 첫번째 매개변수에는 생성할 객체의 프로토타입으로 지정할 객체를 전달한다. 두번째 매개변수에는 생성할 객체의 프로퍼티를 갖는 객체를 전달한다.</p>
<ul>
<li>Object.create 메소드의 장점<ul>
<li>new 연산자가 없이도 객체를 생성할 수 있다.</li>
<li>프로토타입을 지정하면서 객체를 생성할 수 있다. 이때 생성자 함수와 프로토타입 간의 링크가 파괴되지 않는다.</li>
<li>객체 리터럴에 의해 생성된 객체도 특정 객체를 상속받을 수 있다.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="12-2-객체-리터럴-내부에서-proto에-의한-직접-상속"><a href="#12-2-객체-리터럴-내부에서-proto에-의한-직접-상속" class="headerlink" title="12-2. 객체 리터럴 내부에서 proto에 의한 직접 상속"></a>12-2. 객체 리터럴 내부에서 <strong>proto</strong>에 의한 직접 상속</h3><p>ES6에서는 객체 리터럴 내부에서 <strong>proto</strong>접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.</p>
<hr>
<h2 id="13-정적-프로퍼티-메소드"><a href="#13-정적-프로퍼티-메소드" class="headerlink" title="13. 정적 프로퍼티/메소드"></a>13. 정적 프로퍼티/메소드</h2><p>정적프로퍼티/메소드는 생성자 함수로 인수턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다.</p>
<hr>
<h2 id="14-프로퍼티-존재-확인"><a href="#14-프로퍼티-존재-확인" class="headerlink" title="14. 프로퍼티 존재 확인"></a>14. 프로퍼티 존재 확인</h2><p>in 연산자는 객체 내에 프로퍼티가 존재하는지 여부를 확인한다. 그리고 in 연산자는 확인 대상 객체의 프로퍼티 뿐만 아니라 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의 한다.</p>
<hr>
<h2 id="15-프로퍼티-열거"><a href="#15-프로퍼티-열거" class="headerlink" title="15. 프로퍼티 열거"></a>15. 프로퍼티 열거</h2><h3 id="15-1-for…in-문"><a href="#15-1-for…in-문" class="headerlink" title="15-1. for…in 문"></a>15-1. for…in 문</h3><p>객체의 모든 프로퍼티를 순회하며 열거하려면 for…in 문을 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (변수선언문 in  객체) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>for…in 문은 객체의 프로퍼티 개수만큼 반복하며 for…in 문의 변수 선언문에서 선언한 변수에 프로퍼티 키를 할당한다. for…in 문은 프로퍼티 키가 심볼인 프로퍼티는 열거하지 않는다. 배열에는 for…in 문을 사용하지 말고 일반적인 for 문이나 for…of 문 또는 Array.prototype.forEach 메소드를 사용하기를 권장한다.</p>
<hr>
<h3 id="15-2-Object-keys-values-entries-메소드"><a href="#15-2-Object-keys-values-entries-메소드" class="headerlink" title="15-2. Object.keys/values/entries 메소드"></a>15-2. Object.keys/values/entries 메소드</h3><p>객체 자신의 프로퍼티만을 열거하기 위해서는 for…in 문을 사용하는 것 보다 Object.keys/values/entries 메소드를 사용하는 것을 권장한다.<br>Object.keys 메소드는 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환한다.ES8에서 도입된 Object.values 메소드는 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환한다. ES8에서 도입된 Object.entries 메소드는 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/03/%ED%95%A8%EC%88%98%EC%99%80%EC%9D%BC%EA%B8%89%EA%B0%9D%EC%B2%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/%ED%95%A8%EC%88%98%EC%99%80%EC%9D%BC%EA%B8%89%EA%B0%9D%EC%B2%B4/" class="post-title-link" itemprop="url">함수와 일급 객체</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-05 21:42:39 / Modified: 21:58:59" itemprop="dateCreated datePublished" datetime="2020-03-05T21:42:39+09:00">2020-03-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-일급-객체"><a href="#1-일급-객체" class="headerlink" title="1. 일급 객체"></a>1. 일급 객체</h2><ul>
<li>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.     </li>
<li>변수나 자료 구조에 저장할 수 있다.</li>
<li>함수의 매개 변수에게 전달할 수 있다.</li>
<li>함수의 결과값으로 반환할 수 있다.</li>
</ul>
<hr>
<h2 id="2-함수-객체의-프로퍼티"><a href="#2-함수-객체의-프로퍼티" class="headerlink" title="2. 함수 객체의 프로퍼티"></a>2. 함수 객체의 프로퍼티</h2><p>함수는 객체이다. 따라서 함수도 르포퍼티를 가질 수 있다.</p>
<hr>
<h3 id="2-1-arguments-프로퍼티"><a href="#2-1-arguments-프로퍼티" class="headerlink" title="2-1. arguments 프로퍼티"></a>2-1. arguments 프로퍼티</h3><p>함수 객체의 arguments 프로퍼티 값은 arguments 객체이다. arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체(array-like object)이며 함수 내부에서 지역 변수처럼 사용된다.</p>
<hr>
<h3 id="2-2-caller-프로퍼티"><a href="#2-2-caller-프로퍼티" class="headerlink" title="2-2. caller 프로퍼티"></a>2-2. caller 프로퍼티</h3><p>caller 프로퍼티는 ECMAScript 스펙에 포함되지 않은 비표준 프로퍼티이다. 이후 표준화될 예정도 없는 프로퍼티이므로 사용하지 말고 참고로만 알아두면 된다. 함수 객체의 caller 프로퍼티는 함수 자신을 호출한 함수를 가리킨다.</p>
<hr>
<h3 id="2-3-length-프로퍼티"><a href="#2-3-length-프로퍼티" class="headerlink" title="2-3. length 프로퍼티"></a>2-3. length 프로퍼티</h3><p>함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수를 가리킨다.</p>
<hr>
<h3 id="2-4-name-프로퍼티"><a href="#2-4-name-프로퍼티" class="headerlink" title="2-4. name 프로퍼티"></a>2-4. name 프로퍼티</h3><p>함수 객체의 name 프로퍼티는 함수 이름을 나타낸다. name 프로퍼티는 ES6 이전까지는 비표준이었지만 ES6에서 정식 표준이 되었다.<br>name 프로퍼티는 ES5와 ES6에서 동작을 달리 하므로 주의 해야 한다. 익명 함수 표현식의 경우, ES5에서 name 프로퍼티는 빈 문자열을 값으로 갖는다. 하지만 ES6에서는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.</p>
<hr>
<h3 id="2-5-proto접근자-프로퍼티"><a href="#2-5-proto접근자-프로퍼티" class="headerlink" title="2-5. proto접근자 프로퍼티"></a>2-5. <strong>proto</strong>접근자 프로퍼티</h3><p>모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. [[Prototype]] 내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.</p>
<hr>
<h3 id="2-6-prototype-프로퍼티"><a href="#2-6-prototype-프로퍼티" class="headerlink" title="2-6. prototype 프로퍼티"></a>2-6. prototype 프로퍼티</h3><p>prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다.<br>prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/03/%EC%83%9D%EC%84%B1%EC%9E%90%ED%95%A8%EC%88%98%EC%97%90%EC%9D%98%ED%95%9C%EA%B0%9D%EC%B2%B4%EC%83%9D%EC%84%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/%EC%83%9D%EC%84%B1%EC%9E%90%ED%95%A8%EC%88%98%EC%97%90%EC%9D%98%ED%95%9C%EA%B0%9D%EC%B2%B4%EC%83%9D%EC%84%B1/" class="post-title-link" itemprop="url">생성자 함수에 의한 객체 생성</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-04 22:30:20 / Modified: 23:02:33" itemprop="dateCreated datePublished" datetime="2020-03-04T22:30:20+09:00">2020-03-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Object-생성자-함수"><a href="#1-Object-생성자-함수" class="headerlink" title="1. Object 생성자 함수"></a>1. Object 생성자 함수</h2><p>new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성할 수 있다. 생성자 함수에 의해 생성된 객체를 인스턴스라 한다. 자바스크립트는 이외에도 String, Number, Boolean, Function, Array, Date, RegExp 등의 빌트인 생성자 함수를 제공한다.</p>
<hr>
<h2 id="2-생성자-함수"><a href="#2-생성자-함수" class="headerlink" title="2. 생성자 함수"></a>2. 생성자 함수</h2><h3 id="2-1-객체-리터럴에-의한-객체-생성-방식의-문제점"><a href="#2-1-객체-리터럴에-의한-객체-생성-방식의-문제점" class="headerlink" title="2-1. 객체 리터럴에 의한 객체 생성 방식의 문제점"></a>2-1. 객체 리터럴에 의한 객체 생성 방식의 문제점</h3><p>객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만을 생성한다. 따라서 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우, 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다.</p>
<hr>
<h3 id="2-2-생성자-함수에-의한-객체-생성-방식의-장점"><a href="#2-2-생성자-함수에-의한-객체-생성-방식의-장점" class="headerlink" title="2-2. 생성자 함수에 의한 객체 생성 방식의 장점"></a>2-2. 생성자 함수에 의한 객체 생성 방식의 장점</h3><p>생성자 함수에 의한 객체 생성 방식은 마치 객체를 생성하기 위한 템플릿처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.</p>
<hr>
<h3 id="2-3-내부-메소드-Call-과-Construct"><a href="#2-3-내부-메소드-Call-과-Construct" class="headerlink" title="2-3. 내부 메소드 [[Call]]과 [[Construct]]"></a>2-3. 내부 메소드 [[Call]]과 [[Construct]]</h3><p>내부 메소드 [[Call]]을 갖는 함수 객체를 callable이라 하며, 내부 메소드인 [[Construct]]를 갖는 함수 객체를 constructor, [[Construct]]를 갖지 않는 함수 객체를 non-constructor라고 부른다. callable은 호출할 수 있는 객체, 즉 함수를 말하며, constructor는 생성자 함수로서 호출할 수 있는 객체를 의미한다. 생성자 함수로서 호출할 수 있다는 것은 new 연산자(또는 super 연산자)와 함께 호출하는 것을 의미한다.</p>
<hr>
<h3 id="2-4-constructor와-non-constructor의-구분"><a href="#2-4-constructor와-non-constructor의-구분" class="headerlink" title="2-4. constructor와 non-constructor의 구분"></a>2-4. constructor와 non-constructor의 구분</h3><p>일반 함수로 정의된 함수만이 constructor이다. 함수의 종류가 Arrow, Method인 함수는 non-constructor가 된다. 즉, 같이 일반 함수로 정의된 함수만이 생성자 함수로서 호출될 수 있다.</p>
<hr>
<h3 id="2-5-생성자-함수의-인스턴스-생성-과정"><a href="#2-5-생성자-함수의-인스턴스-생성-과정" class="headerlink" title="2-5. 생성자 함수의 인스턴스 생성 과정"></a>2-5. 생성자 함수의 인스턴스 생성 과정</h3><p>생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화하는 것이다.</p>
<ul>
<li>인스턴스 생성과 this바인딩 : 암묵적으로 빈 객체가 생성된다.</li>
<li>인스턴스 초기화 : 생성자 함수에 기술되어 있는 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다.</li>
<li>인스턴스 반환 : 생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.</li>
</ul>
<hr>
<h3 id="2-6-new-연산자"><a href="#2-6-new-연산자" class="headerlink" title="2-6. new 연산자"></a>2-6. new 연산자</h3><p>new 연사자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. 단, new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor이여야 한다. 반대로 new 연산자 없이 생성자 함수를 호출하면 일반 함수로 호출된다.</p>
<hr>
<h3 id="2-7-new-target"><a href="#2-7-new-target" class="headerlink" title="2-7. new.target"></a>2-7. new.target</h3><p>ES6에서는 new.target을 지원한다. this와 유사하게 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라고 부른다. IE는 new.target를 지원하지 않는다. 함수 내부에서 new.target를 사용하면 new 연산자와 함께 함수가 호출되었는지 확인할 수 있다. 함수가 new 연산자와 함께 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. new 연산자 없이 호출된 함수 내부의 new.target은 undefined이다. new 연산자와 함께 생성자 함수에 의해 생성된 객체(인스턴스)는 프로토타입에 의해 생성자 함수와 연결된다. 이를 이용해 new 연산자와 함께 호출되었는지를 확인할 수 있다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/03/%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/" class="post-title-link" itemprop="url">프로퍼티 어트리뷰트</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-03 22:38:14 / Modified: 23:33:48" itemprop="dateCreated datePublished" datetime="2020-03-03T22:38:14+09:00">2020-03-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-내부-슬롯과-내부-메소드"><a href="#1-내부-슬롯과-내부-메소드" class="headerlink" title="1. 내부 슬롯과 내부 메소드"></a>1. 내부 슬롯과 내부 메소드</h2><p>내부 슬롯과 내부 메소드는 자바스크립트 엔진의 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메소드이다. ECMAScript 사양에 등장하는 이중 대괄호 ([[…]])로 감싼 이름들이 내부 슬롯과 내부 메소드이다. 내부 슬롯과 내부 메소드는 자바스크립트 엔진의 내부 로직이므로 원칙적으로 자바스크립트는 내부 슬롯과 내부 메소드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다. 일부 내부 슬롯과 내부 메소드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.</p>
<hr>
<h2 id="2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h2><p>자바스크립트 엔진은 프로퍼티를 생성할 때, 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다. 프로퍼티의 상태란 프로퍼티의 값, 값의 갱신 기능 여부, 열거 가능 여부, 재정의 가능 여부를 말한다. 프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값인 내부 슬롯이다. 따라서 프로퍼티 어트리뷰트에 직접 접근할 수 없지만, Object.getOwnPropertyDescriptor 메소드를 사용하여 간접적으로 확인할 수는 있다. 메소드를 호출할 때, 첫번째 매개변수에는 객체의 참조를 전달하고 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다. 이때 메소드는 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.</p>
<hr>
<h2 id="3-데이터-프로퍼티와-접근자-프로퍼티"><a href="#3-데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="3. 데이터 프로퍼티와 접근자 프로퍼티"></a>3. 데이터 프로퍼티와 접근자 프로퍼티</h2><ul>
<li>데이터 프로퍼티키와 값으로 구성된 일반적인 프로퍼티다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.</li>
<li>접근자 프로퍼티 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티다.</li>
</ul>
<hr>
<h3 id="3-1-데이터-프로퍼티"><a href="#3-1-데이터-프로퍼티" class="headerlink" title="3-1. 데이터 프로퍼티"></a>3-1. 데이터 프로퍼티</h3><ul>
<li>프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체의 프로퍼티 종류와 설명<ul>
<li>[[Value]], value : 프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값이고, 프로퍼티 키로 프로퍼티 값을 저장하면 [[value]]에 값을 저장한다. 이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.</li>
<li>[[Writable]], writable : 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖으며, [[Writable]]의 값이 false인 경우, 해당 프로퍼티의[[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.</li>
<li>[[Enumerable]], enumerable : 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖으며, [[Enumerable]]의 값이 false인 경우, 해당 프로퍼티는 for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다.</li>
<li>[[configurable]], configurable :  프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖으며, [[Configurable]]의 값이 false인 경우, 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-접근자-프로퍼티"><a href="#3-2-접근자-프로퍼티" class="headerlink" title="3-2. 접근자 프로퍼티"></a>3-2. 접근자 프로퍼티</h3><ul>
<li>프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체의 프로퍼티 종류와 설명<ul>
<li>[[Get]], get : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수이다. 즉, 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.</li>
<li>[[Set]], set : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수이다. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</li>
<li>[[Enumerable]], enumerable : 데이터 프로퍼티의 [[Enumerable]]와 같다.</li>
<li>[[Configurable]], configurable : 데이터 프로퍼티의 [[Configurable]]와 같다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-프로퍼티의-정의"><a href="#4-프로퍼티의-정의" class="headerlink" title="4. 프로퍼티의 정의"></a>4. 프로퍼티의 정의</h2><p>프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다.</p>
<h2 id="5-객체-변경-방지"><a href="#5-객체-변경-방지" class="headerlink" title="5. 객체 변경 방지"></a>5. 객체 변경 방지</h2><p>객체는 변경 가능한 값이므로 재할당없이 직접 변경이 가능하다. 프로퍼티를 추가하거나 삭제할 수 있고, 프로퍼티의 값을 갱신할 수 있으며 Object.defineProperty 또는 Object.defineProperties 메소드를 사용하여 프로퍼티 어트리뷰트를 재정의할 수도 있다.</p>
<ul>
<li>객체 확장 금지 Object.preventExtensions로 프로퍼티 추가 X, 프로퍼티 삭제 O, 프로퍼티 값 읽기 O, 프로퍼티 값 쓰기 O, 프로퍼티 어트리뷰트 재정의 O.</li>
<li>객체 밀봉 Object.seal로 프로퍼티 추가 X, 프로퍼티 삭제 X, 프로퍼티 값 읽기 O, 프로퍼티 값 쓰기 O, 프로퍼티 어트리뷰트 재정의 O.</li>
<li>객체 동결 Object.freeze로 프로퍼티 추가 X, 프로퍼티 삭제 X, 프로퍼티 값 읽기 O, 프로퍼티 값 쓰기 X, 프로퍼티 어트리뷰트 재정의 X.</li>
</ul>
<hr>
<h3 id="5-1-객체-확장-금지"><a href="#5-1-객체-확장-금지" class="headerlink" title="5-1. 객체 확장 금지"></a>5-1. 객체 확장 금지</h3><p>Object.preventExtensions 메소드는 객체의 확장을 금지한다. 즉, 확장이 금지된 객체는 프로퍼티 추가가 금지된다.</p>
<hr>
<h3 id="5-2-객체-밀봉"><a href="#5-2-객체-밀봉" class="headerlink" title="5-2. 객체 밀봉"></a>5-2. 객체 밀봉</h3><p>Object.seal 메소드는 객체를 밀봉한다. 즉, 밀봉된 객체는 읽기와 쓰기만 가능하게 된다.</p>
<hr>
<h3 id="5-3-객체-동결"><a href="#5-3-객체-동결" class="headerlink" title="5-3. 객체 동결"></a>5-3. 객체 동결</h3><p>Object.freeze 메소드는 객체를 동결한다. 즉, 동결된 객체는 읽기만 가능하게 된다.</p>
<hr>
<h3 id="5-4-불변-객체"><a href="#5-4-불변-객체" class="headerlink" title="5-4. 불변 객체"></a>5-4. 불변 객체</h3><p>객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용의 불변 객체를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메소드를 호출해야 한다.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wgy5446</p>
  <div class="site-description" itemprop="description">All story about js</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wgy5446</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
