<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wgy5446.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1. 객체지향 프로그래밍객체지향 프로그래밍은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체들의 집합으로 프로그럄을 표현하려는 프로그래밍 패러다임을 말한다.  2. 상속과 프로토타입상속은 객체지향 프로그래밍의 핵심 개념으로 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가">
<meta property="og:type" content="article">
<meta property="og:title" content="Prototype">
<meta property="og:url" content="https://wgy5446.github.io/2020/03/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/index.html">
<meta property="og:site_name" content="John">
<meta property="og:description" content="1. 객체지향 프로그래밍객체지향 프로그래밍은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체들의 집합으로 프로그럄을 표현하려는 프로그래밍 패러다임을 말한다.  2. 상속과 프로토타입상속은 객체지향 프로그래밍의 핵심 개념으로 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-03-09T13:06:37.000Z">
<meta property="article:modified_time" content="2020-03-10T14:06:11.112Z">
<meta property="article:author" content="wgy5446">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content=" js">
<meta property="article:tag" content=" react">
<meta property="article:tag" content=" anqular">
<meta property="article:tag" content=" hhkb">
<meta property="article:tag" content=" realforce">
<meta property="article:tag" content=" leopold">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wgy5446.github.io/2020/03/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Prototype | John</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">John</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">John</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://wgy5446.github.io/2020/03/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wgy5446">
      <meta itemprop="description" content="All story about js">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Prototype
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-09 22:06:37" itemprop="dateCreated datePublished" datetime="2020-03-09T22:06:37+09:00">2020-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-10 23:06:11" itemprop="dateModified" datetime="2020-03-10T23:06:11+09:00">2020-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-객체지향-프로그래밍"><a href="#1-객체지향-프로그래밍" class="headerlink" title="1. 객체지향 프로그래밍"></a>1. 객체지향 프로그래밍</h2><p>객체지향 프로그래밍은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체들의 집합으로 프로그럄을 표현하려는 프로그래밍 패러다임을 말한다.</p>
<hr>
<h2 id="2-상속과-프로토타입"><a href="#2-상속과-프로토타입" class="headerlink" title="2. 상속과 프로토타입"></a>2. 상속과 프로토타입</h2><p>상속은 객체지향 프로그래밍의 핵심 개념으로 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다. 자바스크립트는 프로토타입을 기반으로 상속을 구현한다.</p>
<hr>
<h2 id="3-프로토타입-객체"><a href="#3-프로토타입-객체" class="headerlink" title="3. 프로토타입 객체"></a>3. 프로토타입 객체</h2><p>프로토타입 객체란 객체 지향 프로그래밍의 근간을 이루는 객체간 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티를 제공한다. 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다. 모든 객체는 [[Prototype]] 이라는 내부 슬롯을 갖는다. 모든 객체는 하나의 프로토타입을 갖으며 프로토타입은 객체의 생성 방식에 의해 결정된다. 객체와 프로토타입과 생성자 함수는 서로 연결되어 있다. 객체는 <strong>proto</strong>접근자 프로퍼티를 통해 자신의 [[Prototype]] 내부 슬롯이 가리키는 객체에 접근할 수 있고, 프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있다. 생성자 함수는 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.</p>
<hr>
<h3 id="3-1-proto접근자-프로퍼티"><a href="#3-1-proto접근자-프로퍼티" class="headerlink" title="3-1.proto접근자 프로퍼티"></a>3-1.<strong>proto</strong>접근자 프로퍼티</h3><p>모든 객체는 <strong>proto</strong>접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[prototype]] 내부 슬롯에 접근할 수 있다. <strong>proto</strong>접근자 프로퍼티는 상속을 통해 사용된다.</p>
<hr>
<h3 id="3-2-함수-객체의-prototype-프로퍼티"><a href="#3-2-함수-객체의-prototype-프로퍼티" class="headerlink" title="3-2. 함수 객체의 prototype 프로퍼티"></a>3-2. 함수 객체의 prototype 프로퍼티</h3><p>함수 객체는 <strong>proto</strong>접근자 프로퍼티 이외에 prototype 프로퍼티도 소유한다. 함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. 모든 객체가 가지고 있는 <strong>proto</strong>접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다. 하지만 이들 프로퍼티를 사용하는 주체가 다르다.</p>
<hr>
<h3 id="3-3-프로타입의-constructor-프로퍼티와-생성자-함수"><a href="#3-3-프로타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="3-3. 프로타입의 constructor 프로퍼티와 생성자 함수"></a>3-3. 프로타입의 constructor 프로퍼티와 생성자 함수</h3><p>모든 프로토타입은 constructor 프로퍼티를 갖는다. constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. 이 연결은 함수 객체가 생성될 때 이루어 진다.</p>
<hr>
<h2 id="4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><a href="#4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입" class="headerlink" title="4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입"></a>4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</h2><ul>
<li>리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입<ul>
<li>객체 리터럴 | Object | Object.prototype</li>
<li>함수 리터럴 | Function | Function.prototype</li>
<li>배열 리터럴 | Array | Array.prototype</li>
<li>정규 표현식 리터럴 | RegExp | RegExp.prototype</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-프로토타입의-생성-시점"><a href="#5-프로토타입의-생성-시점" class="headerlink" title="5. 프로토타입의 생성 시점"></a>5. 프로토타입의 생성 시점</h2><p>프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.</p>
<hr>
<h3 id="5-1-사용자-정의-생성자-함수와-프로토타입-생성-시점"><a href="#5-1-사용자-정의-생성자-함수와-프로토타입-생성-시점" class="headerlink" title="5-1. 사용자 정의 생성자 함수와 프로토타입 생성 시점"></a>5-1. 사용자 정의 생성자 함수와 프로토타입 생성 시점</h3><p>생성자 함수로서 호출할 수 있는 함수, 즉 constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다. non-constructor는 프로토타입이 생성되지 않는다.</p>
<hr>
<h3 id="5-2-빌트인-생성자-함수와-프로토타입-생성-시점"><a href="#5-2-빌트인-생성자-함수와-프로토타입-생성-시점" class="headerlink" title="5-2. 빌트인 생성자 함수와 프로토타입 생성 시점"></a>5-2. 빌트인 생성자 함수와 프로토타입 생성 시점</h3><p>빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성된다. 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 이때 빌트인 생성자 함수와 더불어 프로토타입이 생성된다. 생성된 프로토타입은 빌트인 생성자 함수의 Prototype 프로퍼티에 바인딩된다.</p>
<hr>
<h2 id="6-객체-생성-방식과-프로토타입의-결정"><a href="#6-객체-생성-방식과-프로토타입의-결정" class="headerlink" title="6. 객체 생성 방식과 프로토타입의 결정"></a>6. 객체 생성 방식과 프로토타입의 결정</h2><ul>
<li>다양한 객체 생성 방법<ul>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create 메소드</li>
<li>클래스 (ES6)</li>
</ul>
</li>
</ul>
<p>프로토타입은 추상 연산 ObjectCreate에 전달되는 인수에 의해 결정된다. 이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.</p>
<hr>
<h3 id="6-1-객체-리터럴에-의해-생성된-객체의-프로토타입"><a href="#6-1-객체-리터럴에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-1. 객체 리터럴에 의해 생성된 객체의 프로토타입"></a>6-1. 객체 리터럴에 의해 생성된 객체의 프로토타입</h3><p>자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할 때, 추상 연산 ObjectCreate를 호출한다.</p>
<hr>
<h3 id="6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-2. Object 생성자 함수에 의해 생성된 객체의 프로토타입"></a>6-2. Object 생성자 함수에 의해 생성된 객체의 프로토타입</h3><p>명시적으로 Object 생성자 함수를 호출하여 객체를 생성하면 빈 객체가 생성된다. Object 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 추상 연산 ObjectCreate를 호출한다. 이때 Object 생성자 함수에 의해 생성되는 객체의 프로토타입은 Object.prototype이다. </p>
<hr>
<h3 id="6-3-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#6-3-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-3. 생성자 함수에 의해 생성된 객체의 프로토타입"></a>6-3. 생성자 함수에 의해 생성된 객체의 프로토타입</h3><p>new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다. 이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 즉, 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 빌트인 객체인 Object 생성자 함수와 더불어 생성된 프로토타입 Object.prototype은 다양한 빌트인 메소드(hasOwnProperty, propertyIsEnumerable 등)를 갖고 있다.</p>
<hr>
<h2 id="7-프로토타입-체인"><a href="#7-프로토타입-체인" class="headerlink" title="7. 프로토타입 체인"></a>7. 프로토타입 체인</h2><p>자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <strong>proto</strong>접근자 프로퍼티가 가리키는 링크를 따라 잔신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이것을 프로토타입 체인이라 한다. 프로토타입 체인은 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘이다.</p>
<hr>
<h2 id="8-캡슐화"><a href="#8-캡슐화" class="headerlink" title="8. 캡슐화"></a>8. 캡슐화</h2><p>캘슐화는 정보의 일부를 외부에 감추어 은닉하는 것을 말한다. 즉, 외부에 공개할 필요가 없는 구현의 일부를 외부에 노출되지 않도록 감추어 적절치 못한 접근으로부터 정보를 보호하고 객체간의 상호 의존성, 즉 결합도를 낮추는 효과가 얻는다.</p>
<hr>
<h2 id="9-오버라이딩과-프로퍼티-쉐도잉"><a href="#9-오버라이딩과-프로퍼티-쉐도잉" class="headerlink" title="9. 오버라이딩과 프로퍼티 쉐도잉"></a>9. 오버라이딩과 프로퍼티 쉐도잉</h2><p>오버라이딩은 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의하여 사용하는 방식이다. 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가한다. 이때 인스턴스 메소드 sayHello는 프로토타입 메소드 sayHello를 오버라이딩하였고 프로토타입 메소드 sayHello는 가려진다.</p>
<hr>
<h2 id="10-프로토타입의-교체"><a href="#10-프로토타입의-교체" class="headerlink" title="10. 프로토타입의 교체"></a>10. 프로토타입의 교체</h2><p>프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있다.</p>
<hr>
<h3 id="10-1-생성자-함수에-의한-프로토타입의-교체"><a href="#10-1-생성자-함수에-의한-프로토타입의-교체" class="headerlink" title="10-1. 생성자 함수에 의한 프로토타입의 교체"></a>10-1. 생성자 함수에 의한 프로토타입의 교체</h3><p>생성자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체한 객체 리터럴에는 constructor 프로퍼티가 없다. constructor 프로퍼티는 자바스크립트 엔진이 프로토타입을 생성할 때 암묵적으로 추가한 프로퍼티이다. 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다. 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티를 되살린다.</p>
<hr>
<h3 id="10-2-인스턴스에-의한-프로토타입의-교체"><a href="#10-2-인스턴스에-의한-프로토타입의-교체" class="headerlink" title="10-2. 인스턴스에 의한 프로토타입의 교체"></a>10-2. 인스턴스에 의한 프로토타입의 교체</h3><p>프로토타입은 생성자 함수의 prototype 프로퍼티 뿐만 아니라 인스턴스의 <strong>proto</strong>접근자 프로퍼티로 접근할 수 있고 프로토타입을 교체할 수 있다. 생성자 함수의 prototype 프로퍼티에 다른 임의의 객체를 바인딩하는 것은 미래에 생성할 인스턴스의 프로토타입을 교체할 수 있다. 생성자 함수에 의한 프로토타입 교체와 마찬가지로 인스턴스에 의한 포로토타입 교체도 constructor 프로퍼티와 생성자 함수 간의 연결을 파괴한다. 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하고 생성자 함수의 prototype 프로퍼티를 재설정하여 파괴된 생성자 함수와 프로토타입 간의 연결을 되살릴 수 있다.</p>
<hr>
<h2 id="11-instanceof연산자"><a href="#11-instanceof연산자" class="headerlink" title="11. instanceof연산자"></a>11. instanceof연산자</h2><p>instanceof연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자,우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 만약 우변의 피연산자가 함수가 아닌 경우, TypeError가 발생한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">객체 instancof 생성자 함수</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="12-직접-상속"><a href="#12-직접-상속" class="headerlink" title="12. 직접 상속"></a>12. 직접 상속</h2><h3 id="12-1-Object-create에-의한-직접-상속"><a href="#12-1-Object-create에-의한-직접-상속" class="headerlink" title="12-1. Object.create에 의한 직접 상속"></a>12-1. Object.create에 의한 직접 상속</h3><p>Object.create 메소드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. Object.create 메소드도 다른 객체 생성 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다. Object.create 메소드의 첫번째 매개변수에는 생성할 객체의 프로토타입으로 지정할 객체를 전달한다. 두번째 매개변수에는 생성할 객체의 프로퍼티를 갖는 객체를 전달한다.</p>
<ul>
<li>Object.create 메소드의 장점<ul>
<li>new 연산자가 없이도 객체를 생성할 수 있다.</li>
<li>프로토타입을 지정하면서 객체를 생성할 수 있다. 이때 생성자 함수와 프로토타입 간의 링크가 파괴되지 않는다.</li>
<li>객체 리터럴에 의해 생성된 객체도 특정 객체를 상속받을 수 있다.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="12-2-객체-리터럴-내부에서-proto에-의한-직접-상속"><a href="#12-2-객체-리터럴-내부에서-proto에-의한-직접-상속" class="headerlink" title="12-2. 객체 리터럴 내부에서 proto에 의한 직접 상속"></a>12-2. 객체 리터럴 내부에서 <strong>proto</strong>에 의한 직접 상속</h3><p>ES6에서는 객체 리터럴 내부에서 <strong>proto</strong>접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.</p>
<hr>
<h2 id="13-정적-프로퍼티-메소드"><a href="#13-정적-프로퍼티-메소드" class="headerlink" title="13. 정적 프로퍼티/메소드"></a>13. 정적 프로퍼티/메소드</h2><p>정적프로퍼티/메소드는 생성자 함수로 인수턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다.</p>
<hr>
<h2 id="14-프로퍼티-존재-확인"><a href="#14-프로퍼티-존재-확인" class="headerlink" title="14. 프로퍼티 존재 확인"></a>14. 프로퍼티 존재 확인</h2><p>in 연산자는 객체 내에 프로퍼티가 존재하는지 여부를 확인한다. 그리고 in 연산자는 확인 대상 객체의 프로퍼티 뿐만 아니라 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의 한다.</p>
<hr>
<h2 id="15-프로퍼티-열거"><a href="#15-프로퍼티-열거" class="headerlink" title="15. 프로퍼티 열거"></a>15. 프로퍼티 열거</h2><h3 id="15-1-for…in-문"><a href="#15-1-for…in-문" class="headerlink" title="15-1. for…in 문"></a>15-1. for…in 문</h3><p>객체의 모든 프로퍼티를 순회하며 열거하려면 for…in 문을 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (변수선언문 in  객체) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>for…in 문은 객체의 프로퍼티 개수만큼 반복하며 for…in 문의 변수 선언문에서 선언한 변수에 프로퍼티 키를 할당한다. for…in 문은 프로퍼티 키가 심볼인 프로퍼티는 열거하지 않는다. 배열에는 for…in 문을 사용하지 말고 일반적인 for 문이나 for…of 문 또는 Array.prototype.forEach 메소드를 사용하기를 권장한다.</p>
<hr>
<h3 id="15-2-Object-keys-values-entries-메소드"><a href="#15-2-Object-keys-values-entries-메소드" class="headerlink" title="15-2. Object.keys/values/entries 메소드"></a>15-2. Object.keys/values/entries 메소드</h3><p>객체 자신의 프로퍼티만을 열거하기 위해서는 for…in 문을 사용하는 것 보다 Object.keys/values/entries 메소드를 사용하는 것을 권장한다.<br>Object.keys 메소드는 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환한다.ES8에서 도입된 Object.values 메소드는 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환한다. ES8에서 도입된 Object.entries 메소드는 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다.</p>
<hr>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/%ED%95%A8%EC%88%98%EC%99%80%EC%9D%BC%EA%B8%89%EA%B0%9D%EC%B2%B4/" rel="prev" title="함수와 일급 객체">
      <i class="fa fa-chevron-left"></i> 함수와 일급 객체
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/%EC%97%84%EA%B2%A9%EB%AA%A8%EB%93%9C/" rel="next" title="Strict mode">
      Strict mode <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-객체지향-프로그래밍"><span class="nav-number">1.</span> <span class="nav-text">1. 객체지향 프로그래밍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-상속과-프로토타입"><span class="nav-number">2.</span> <span class="nav-text">2. 상속과 프로토타입</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-프로토타입-객체"><span class="nav-number">3.</span> <span class="nav-text">3. 프로토타입 객체</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-proto접근자-프로퍼티"><span class="nav-number">3.1.</span> <span class="nav-text">3-1.proto접근자 프로퍼티</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-함수-객체의-prototype-프로퍼티"><span class="nav-number">3.2.</span> <span class="nav-text">3-2. 함수 객체의 prototype 프로퍼티</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-프로타입의-constructor-프로퍼티와-생성자-함수"><span class="nav-number">3.3.</span> <span class="nav-text">3-3. 프로타입의 constructor 프로퍼티와 생성자 함수</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><span class="nav-number">4.</span> <span class="nav-text">4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-프로토타입의-생성-시점"><span class="nav-number">5.</span> <span class="nav-text">5. 프로토타입의 생성 시점</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-사용자-정의-생성자-함수와-프로토타입-생성-시점"><span class="nav-number">5.1.</span> <span class="nav-text">5-1. 사용자 정의 생성자 함수와 프로토타입 생성 시점</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-빌트인-생성자-함수와-프로토타입-생성-시점"><span class="nav-number">5.2.</span> <span class="nav-text">5-2. 빌트인 생성자 함수와 프로토타입 생성 시점</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-객체-생성-방식과-프로토타입의-결정"><span class="nav-number">6.</span> <span class="nav-text">6. 객체 생성 방식과 프로토타입의 결정</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-객체-리터럴에-의해-생성된-객체의-프로토타입"><span class="nav-number">6.1.</span> <span class="nav-text">6-1. 객체 리터럴에 의해 생성된 객체의 프로토타입</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입"><span class="nav-number">6.2.</span> <span class="nav-text">6-2. Object 생성자 함수에 의해 생성된 객체의 프로토타입</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-생성자-함수에-의해-생성된-객체의-프로토타입"><span class="nav-number">6.3.</span> <span class="nav-text">6-3. 생성자 함수에 의해 생성된 객체의 프로토타입</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-프로토타입-체인"><span class="nav-number">7.</span> <span class="nav-text">7. 프로토타입 체인</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-캡슐화"><span class="nav-number">8.</span> <span class="nav-text">8. 캡슐화</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-오버라이딩과-프로퍼티-쉐도잉"><span class="nav-number">9.</span> <span class="nav-text">9. 오버라이딩과 프로퍼티 쉐도잉</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-프로토타입의-교체"><span class="nav-number">10.</span> <span class="nav-text">10. 프로토타입의 교체</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-생성자-함수에-의한-프로토타입의-교체"><span class="nav-number">10.1.</span> <span class="nav-text">10-1. 생성자 함수에 의한 프로토타입의 교체</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-인스턴스에-의한-프로토타입의-교체"><span class="nav-number">10.2.</span> <span class="nav-text">10-2. 인스턴스에 의한 프로토타입의 교체</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-instanceof연산자"><span class="nav-number">11.</span> <span class="nav-text">11. instanceof연산자</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-직접-상속"><span class="nav-number">12.</span> <span class="nav-text">12. 직접 상속</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-Object-create에-의한-직접-상속"><span class="nav-number">12.1.</span> <span class="nav-text">12-1. Object.create에 의한 직접 상속</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-객체-리터럴-내부에서-proto에-의한-직접-상속"><span class="nav-number">12.2.</span> <span class="nav-text">12-2. 객체 리터럴 내부에서 proto에 의한 직접 상속</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-정적-프로퍼티-메소드"><span class="nav-number">13.</span> <span class="nav-text">13. 정적 프로퍼티&#x2F;메소드</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-프로퍼티-존재-확인"><span class="nav-number">14.</span> <span class="nav-text">14. 프로퍼티 존재 확인</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-프로퍼티-열거"><span class="nav-number">15.</span> <span class="nav-text">15. 프로퍼티 열거</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-for…in-문"><span class="nav-number">15.1.</span> <span class="nav-text">15-1. for…in 문</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-Object-keys-values-entries-메소드"><span class="nav-number">15.2.</span> <span class="nav-text">15-2. Object.keys&#x2F;values&#x2F;entries 메소드</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wgy5446</p>
  <div class="site-description" itemprop="description">All story about js</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wgy5446</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
